
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç‹å›½ä¿å«æˆ˜ | å¢å¼ºç‰ˆå¡”é˜²</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #2c3e50);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #fff;
            overflow-x: hidden;
        }
        
        .game-header {
            text-align: center;
            margin-bottom: 20px;
            width: 100%;
            max-width: 1000px;
        }
        
        .game-title {
            font-size: 3.5rem;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
            color: #FFD700;
            letter-spacing: 2px;
            background: linear-gradient(to right, #FFD700, #FFA500, #FF6347);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .game-subtitle {
            font-size: 1.2rem;
            margin-bottom: 20px;
            color: #ddd;
        }
        
        .game-container {
            position: relative;
            width: 800px;
            height: 500px;
            margin: 0 auto 20px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            overflow: hidden;
        }
        
        canvas {
            background: linear-gradient(to bottom, #0c2461, #1e3799);
            display: block;
        }
        
        .stats-bar {
            display: flex;
            justify-content: space-between;
            width: 800px;
            margin-bottom: 20px;
            background: rgba(0, 0, 0, 0.4);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid rgba(255, 215, 0, 0.4);
        }
        
        .stat {
            display: flex;
            align-items: center;
            font-size: 1.2rem;
            font-weight: bold;
        }
        
        .stat-icon {
            margin-right: 10px;
            font-size: 1.5rem;
        }
        
        .tower-selector {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            width: 800px;
            flex-wrap: wrap;
        }
        
        .tower-option {
            width: 100px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        
        .tower-option:hover {
            transform: translateY(-5px);
            background: rgba(50, 50, 150, 0.6);
            border-color: #4CAF50;
        }
        
        .tower-option.selected {
            border-color: #FFD700;
            background: rgba(100, 100, 200, 0.7);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
        }
        
        .tower-icon {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .tower-name {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .tower-cost {
            color: #FFD700;
            font-size: 0.9rem;
        }
        
        .tower-damage {
            font-size: 0.8rem;
            color: #FF5252;
            margin-top: 3px;
        }
        
        .tower-range {
            font-size: 0.8rem;
            color: #4CAF50;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            width: 800px;
        }
        
        button {
            flex: 1;
            padding: 15px;
            font-size: 1.1rem;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            background: linear-gradient(to right, #FFD700, #FFA500);
            color: #222;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .game-info {
            margin-top: 20px;
            max-width: 800px;
            background: rgba(0, 0, 0, 0.4);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid rgba(255, 215, 0, 0.4);
        }
        
        .info-title {
            color: #FFD700;
            margin-bottom: 10px;
            text-align: center;
            font-size: 1.4rem;
        }
        
        .info-content {
            line-height: 1.6;
        }
        
        .highlight {
            color: #FFD700;
            font-weight: bold;
        }
        
        .level-selector {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
            width: 800px;
        }
        
        .level-option {
            padding: 12px 25px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            font-weight: bold;
        }
        
        .level-option:hover {
            transform: translateY(-3px);
            background: rgba(50, 50, 150, 0.6);
        }
        
        .level-option.selected {
            border-color: #FFD700;
            background: rgba(100, 100, 200, 0.7);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.7);
        }
        
        .level-1 {
            background: linear-gradient(to right, #4CAF50, #2E7D32);
        }
        
        .level-2 {
            background: linear-gradient(to right, #2196F3, #1565C0);
        }
        
        .level-3 {
            background: linear-gradient(to right, #F44336, #C62828);
        }
        
        .level-4 {
            background: linear-gradient(to right, #9C27B0, #6A1B9A);
        }
        
        .upgrade-info {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
            border: 2px solid #FFD700;
            color: white;
            font-size: 14px;
            pointer-events: none;
            z-index: 100;
            max-width: 200px;
        }
        
        .encyclopedia-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #FFD700;
            border-radius: 30px;
            color: #FFD700;
            font-weight: bold;
            cursor: pointer;
            z-index: 10;
            transition: all 0.3s;
        }
        
        .encyclopedia-btn:hover {
            background: rgba(255, 215, 0, 0.2);
            transform: scale(1.05);
        }
        
        .encyclopedia-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        
        .encyclopedia-modal.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .encyclopedia-content {
            width: 90%;
            max-width: 900px;
            max-height: 90vh;
            background: linear-gradient(to bottom, #2c3e50, #1a2a6c);
            border-radius: 15px;
            padding: 30px;
            overflow-y: auto;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            border: 3px solid #FFD700;
        }
        
        .encyclopedia-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #FFD700;
        }
        
        .encyclopedia-title {
            font-size: 2.5rem;
            color: #FFD700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        
        .close-btn {
            background: #F44336;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .close-btn:hover {
            transform: rotate(90deg) scale(1.1);
        }
        
        .encyclopedia-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .encyclopedia-tab {
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .encyclopedia-tab.active {
            background: #FFD700;
            color: #222;
            font-weight: bold;
        }
        
        .encyclopedia-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
        }
        
        .encyclopedia-item {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            border: 2px solid #4CAF50;
            transition: all 0.3s;
        }
        
        .encyclopedia-item:hover {
            transform: translateY(-5px);
            border-color: #FFD700;
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.3);
        }
        
        .encyclopedia-icon {
            font-size: 3rem;
            margin-bottom: 10px;
        }
        
        .encyclopedia-name {
            font-size: 1.2rem;
            margin-bottom: 10px;
            color: #FFD700;
        }
        
        .encyclopedia-stats {
            font-size: 0.9rem;
            text-align: left;
        }
        
        .encyclopedia-stats div {
            margin: 5px 0;
        }
        
        .difficulty-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            margin-top: 10px;
        }
        
        .difficulty-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #777;
        }
        
        .difficulty-dot.active {
            background: #FFD700;
        }
        
        .status-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px 40px;
            border-radius: 10px;
            border: 3px solid #FFD700;
            color: white;
            font-size: 2rem;
            font-weight: bold;
            text-align: center;
            z-index: 200;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        @media (max-width: 850px) {
            .game-container, .stats-bar, .tower-selector, .controls, .level-selector {
                width: 95%;
                max-width: 600px;
            }
            
            .game-title {
                font-size: 2.5rem;
            }
            
            .tower-option {
                width: 85px;
                padding: 10px;
            }
            
            .encyclopedia-content {
                padding: 15px;
            }
            
            .encyclopedia-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            }
        }
        
        .difficulty-selector {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
            width: 800px;
        }
        
        .difficulty-option {
            padding: 12px 25px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            font-weight: bold;
        }
        
        .difficulty-option:hover {
            transform: translateY(-3px);
            background: rgba(50, 50, 150, 0.6);
        }
        
        .difficulty-option.selected {
            border-color: #FFD700;
            background: rgba(100, 100, 200, 0.7);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.7);
        }
        
        .difficulty-easy {
            background: linear-gradient(to right, #4CAF50, #2E7D32);
        }
        
        .difficulty-medium {
            background: linear-gradient(to right, #2196F3, #1565C0);
        }
        
        .difficulty-hard {
            background: linear-gradient(to right, #F44336, #C62828);
        }
        
        .upgrade-effect {
            position: absolute;
            pointer-events: none;
            z-index: 50;
        }
    </style>
</head>
<body>
    <div class="game-header">
        <h1 class="game-title">ç‹å›½ä¿å«æˆ˜</h1>
        <p class="game-subtitle">å¢å¼ºç‰ˆå¡”é˜² - æ–°å¢å……èƒ½ç¦»å­ç‚®ã€å…‰æ£±å¡”ã€å°¤é‡Œå¡”</p>
    </div>
    
    <div class="difficulty-selector">
        <div class="difficulty-option difficulty-easy selected" data-difficulty="1">ç®€å•</div>
        <div class="difficulty-option difficulty-medium" data-difficulty="2">ä¸­ç­‰</div>
        <div class="difficulty-option difficulty-hard" data-difficulty="3">å›°éš¾</div>
    </div>
    
    <div class="level-selector">
        <div class="level-option level-1 selected" data-level="1">æ£®æ—å…³å¡</div>
        <div class="level-option level-2" data-level="2">æ²™æ¼ å…³å¡</div>
        <div class="level-option level-3" data-level="3">é›ªå±±å…³å¡</div>
        <div class="level-option level-4" data-level="4">æœ€ç»ˆå…³å¡</div>
    </div>
    
    <div class="stats-bar">
        <div class="stat">
            <span class="stat-icon">ğŸ’°</span>
            <span>é‡‘å¸: <span id="gold">300</span></span>
        </div>
        <div class="stat">
            <span class="stat-icon">â¤ï¸</span>
            <span>ç”Ÿå‘½å€¼: <span id="lives">5</span></span>
        </div>
        <div class="stat">
            <span class="stat-icon">âš”ï¸</span>
            <span>æ³¢æ•°: <span id="wave">0</span>/<span id="max-wave">10</span></span>
        </div>
        <div class="stat">
            <span class="stat-icon">ğŸ°</span>
            <span>æ•Œäºº: <span id="enemies">0</span></span>
        </div>
        <div class="stat">
            <span class="stat-icon">ğŸ†</span>
            <span>å…³å¡: <span id="level">1</span>/4</span>
        </div>
    </div>
    
    <div class="game-container">
        <canvas id="gameCanvas" width="800" height="500"></canvas>
        <button class="encyclopedia-btn">ğŸ“š å›¾é‰´</button>
        <div class="status-message" id="statusMessage"></div>
    </div>
    
    <div class="tower-selector">
        <div class="tower-option" data-type="archer" data-cost="70">
            <div class="tower-icon">ğŸ¹</div>
            <div class="tower-name">å¼“ç®­å¡”</div>
            <div class="tower-cost">$70</div>
            <div class="tower-damage">ä¼¤å®³: 15</div>
            <div class="tower-range">èŒƒå›´: 120</div>
        </div>
        <div class="tower-option" data-type="cannon" data-cost="120">
            <div class="tower-icon">ğŸ’£</div>
            <div class="tower-name">ç«ç‚®å¡”</div>
            <div class="tower-cost">$120</div>
            <div class="tower-damage">ä¼¤å®³: 30</div>
            <div class="tower-range">èŒƒå›´: 100</div>
        </div>
        <div class="tower-option" data-type="mage" data-cost="150">
            <div class="tower-icon">ğŸ”®</div>
            <div class="tower-name">æ³•å¸ˆå¡”</div>
            <div class="tower-cost">$150</div>
            <div class="tower-damage">ä¼¤å®³: 5</div>
            <div class="tower-range">èŒƒå›´: 140</div>
        </div>
        <div class="tower-option" data-type="barracks" data-cost="100">
            <div class="tower-icon">ğŸ›¡ï¸</div>
            <div class="tower-name">å…µè¥</div>
            <div class="tower-cost">$100</div>
            <div class="tower-damage">å£«å…µ: 3</div>
            <div class="tower-range">èŒƒå›´: 120</div>
        </div>
        <div class="tower-option" data-type="ice" data-cost="130">
            <div class="tower-icon">â„ï¸</div>
            <div class="tower-name">å¯’å†°å¡”</div>
            <div class="tower-cost">$130</div>
            <div class="tower-damage">ä¼¤å®³: 10</div>
            <div class="tower-range">èŒƒå›´: 130</div>
        </div>
        <div class="tower-option" data-type="lightning" data-cost="180">
            <div class="tower-icon">âš¡</div>
            <div class="tower-name">é›·ç”µå¡”</div>
            <div class="tower-cost">$180</div>
            <div class="tower-damage">ä¼¤å®³: 15</div>
            <div class="tower-range">èŒƒå›´: 150</div>
        </div>
        <div class="tower-option" data-type="missile" data-cost="200">
            <div class="tower-icon">ğŸš€</div>
            <div class="tower-name">å¯¼å¼¹å¡”</div>
            <div class="tower-cost">$200</div>
            <div class="tower-damage">ä¼¤å®³: 80</div>
            <div class="tower-range">èŒƒå›´: 140</div>
        </div>
        <div class="tower-option" data-type="poison" data-cost="160">
            <div class="tower-icon">â˜ ï¸</div>
            <div class="tower-name">æ¯’å¡”</div>
            <div class="tower-cost">$160</div>
            <div class="tower-damage">ä¼¤å®³: 15/ç§’</div>
            <div class="tower-range">èŒƒå›´: 110</div>
        </div>
        <div class="tower-option" data-type="ion" data-cost="200">
            <div class="tower-icon">ğŸ”‹</div>
            <div class="tower-name">ç¦»å­ç‚®</div>
            <div class="tower-cost">$200</div>
            <div class="tower-damage">ä¼¤å®³: 30</div>
            <div class="tower-range">èŒƒå›´: 150</div>
        </div>
        <div class="tower-option" data-type="prism" data-cost="350">
            <div class="tower-icon">âœ¨</div>
            <div class="tower-name">å…‰æ£±å¡”</div>
            <div class="tower-cost">$350</div>
            <div class="tower-damage">ä¼¤å®³: 50</div>
            <div class="tower-range">èŒƒå›´: 140</div>
        </div>
        <div class="tower-option" data-type="yuri" data-cost="100">
            <div class="tower-icon">ğŸ§ </div>
            <div class="tower-name">å°¤é‡Œå¡”</div>
            <div class="tower-cost">$100</div>
            <div class="tower-damage">æ§åˆ¶: 5ç§’</div>
            <div class="tower-range">èŒƒå›´: 120</div>
        </div>
		<div class="tower-option" data-type="laser" data-cost="220">
            <div class="tower-icon">ğŸ”¦</div>
            <div class="tower-name">æ¿€å…‰å¡”</div>
            <div class="tower-cost">$220</div>
            <div class="tower-damage">ä¼¤å®³: 35/ç§’</div>
            <div class="tower-range">èŒƒå›´: 200</div>
        </div>
        <div class="tower-option" data-type="nuke" data-cost="1">
            <div class="tower-icon">â˜¢ï¸</div>
            <div class="tower-name">æ²¡å…³å°±æ˜¯å¼€äº†ï¼Ÿ</div>
            <div class="tower-cost">$1</div>
            <div class="tower-damage">ä¼¤å®³: 9999</div>
            <div class="tower-range">èŒƒå›´: å…¨å±</div>
        </div>
        <div class="tower-option" data-type="energizer" data-cost="280">
            <div class="tower-icon">âš¡</div>
            <div class="tower-name">è“„èƒ½å¡”</div>
            <div class="tower-cost">$280</div>
            <div class="tower-damage">ä¼¤å®³: 20-100</div>
            <div class="tower-range">èŒƒå›´: 130</div>
        </div>
    </div>
    
    <div class="controls">
        <button id="startBtn">å¼€å§‹æ¸¸æˆ</button>
        <button id="nextWaveBtn" disabled>ä¸‹ä¸€æ³¢æ•Œäºº</button>
        <button id="upgradeBtn" disabled>å‡çº§å¡” ($100)</button>
    </div>
    
    <div class="game-info">
        <h3 class="info-title">æ¸¸æˆè¯´æ˜</h3>
        <p class="info-content">
            1. æ–°å¢ä¸‰ç§é˜²å¾¡å¡”ï¼š<span class="highlight">å……èƒ½ç¦»å­ç‚®</span>ã€<span class="highlight">å…‰æ£±å¡”</span>ã€<span class="highlight">å°¤é‡Œå¡”</span><br>
            2. å……èƒ½ç¦»å­ç‚®ï¼šé«˜ä¼¤å®³èŒƒå›´æ”»å‡»ï¼Œå……èƒ½åå‘å°„<br>
            3. å…‰æ£±å¡”ï¼šå…‰æŸæŠ˜å°„æ”»å‡»å¤šä¸ªæ•Œäººï¼Œä¼¤å®³éšæŠ˜å°„è¡°å‡<br>
            4. å°¤é‡Œå¡”ï¼šæ§åˆ¶æ•Œäººä½¿å…¶å€’æˆˆæ”»å‡»å…¶ä»–æ•Œäºº<br>
            5. ä¿®å¤ï¼š<span class="highlight">æš‚åœ/ç»§ç»­æ³¢æ•°BUG</span> å’Œ <span class="highlight">å…µè¥ç‹¬ç«‹å‡çº§</span><br>
            6. é€‰æ‹©é˜²å¾¡å¡”ç±»å‹ï¼Œç„¶ååœ¨åœ°å›¾ä¸Šçš„<span class="highlight">ç»¿è‰²åŒºåŸŸ</span>æ”¾ç½®é˜²å¾¡å¡”<br>
            7. é˜²å¾¡å¡”æœ€å¤šå¯å‡çº§<span class="highlight">3æ¬¡</span>ï¼ˆæœ€é«˜ç­‰çº§4çº§ï¼‰<br>
            8. å‡»è´¥æ•Œäººè·å¾—é‡‘å¸ï¼Œç”¨äºå»ºé€ å’Œå‡çº§é˜²å¾¡å¡”<br>
            9. ä¸è¦è®©æ•Œäººåˆ°è¾¾åŸå ¡ï¼Œå¦åˆ™ä¼šå¤±å»ç”Ÿå‘½å€¼<br>
            10. å®Œæˆæ‰€æœ‰4ä¸ªå…³å¡å³å¯è·èƒœï¼
        </p>
    </div>
    
    <!-- å›¾é‰´æ¨¡æ€æ¡† -->
    <div class="encyclopedia-modal">
        <div class="encyclopedia-content">
            <div class="encyclopedia-header">
                <h2 class="encyclopedia-title">ç‹å›½ä¿å«æˆ˜å›¾é‰´</h2>
                <button class="close-btn">Ã—</button>
            </div>
            
            <div class="encyclopedia-tabs">
                <div class="encyclopedia-tab active" data-tab="towers">é˜²å¾¡å¡”</div>
                <div class="encyclopedia-tab" data-tab="enemies">æ•Œäºº</div>
                <div class="encyclopedia-tab" data-tab="levels">å…³å¡</div>
            </div>
            
            <div class="encyclopedia-grid" id="towers-tab">
                <!-- é˜²å¾¡å¡”ä¿¡æ¯å°†é€šè¿‡JSåŠ¨æ€ç”Ÿæˆ -->
            </div>
            
            <div class="encyclopedia-grid" id="enemies-tab" style="display:none;">
                <!-- æ•Œäººä¿¡æ¯å°†é€šè¿‡JSåŠ¨æ€ç”Ÿæˆ -->
            </div>
            
            <div class="encyclopedia-grid" id="levels-tab" style="display:none;">
                <!-- å…³å¡ä¿¡æ¯å°†é€šè¿‡JSåŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>
    </div>
    
    <div id="upgradeTooltip" class="upgrade-info" style="display: none;"></div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const goldDisplay = document.getElementById('gold');
            const livesDisplay = document.getElementById('lives');
            const waveDisplay = document.getElementById('wave');
            const maxWaveDisplay = document.getElementById('max-wave');
            const enemiesDisplay = document.getElementById('enemies');
            const levelDisplay = document.getElementById('level');
            const startBtn = document.getElementById('startBtn');
            const nextWaveBtn = document.getElementById('nextWaveBtn');
            const upgradeBtn = document.getElementById('upgradeBtn');
            const towerOption = document.querySelectorAll('.tower-option');
            const levelOption = document.querySelectorAll('.level-option');
            const difficultyOption = document.querySelectorAll('.difficulty-option');
            const upgradeTooltip = document.getElementById('upgradeTooltip');
            const encyclopediaBtn = document.querySelector('.encyclopedia-btn');
            const encyclopediaModal = document.querySelector('.encyclopedia-modal');
            const closeBtn = document.querySelector('.close-btn');
            const encyclopediaTabs = document.querySelectorAll('.encyclopedia-tab');
            const towersTab = document.getElementById('towers-tab');
            const enemiesTab = document.getElementById('enemies-tab');
            const levelsTab = document.getElementById('levels-tab');
            const statusMessage = document.getElementById('statusMessage');
            
            // æ¸¸æˆçŠ¶æ€
            const gameState = {
                gold: 300,
                lives: 5,
                wave: 1,
                maxWave: 10,
                enemies: [],
                towers: [],
                soldiers: [],
                projectiles: [],
                effects: [],
                selectedTowerType: null,
                selectedTower: null,
                path: [],
                gameRunning: false,
                gameOver: false,
                gameWon: false,
                lastTime: 0,
                currentLevel: 1,
                maxLevel: 4,
                levelComplete: false,
                difficulty: 1, // 1-3 è¡¨ç¤ºéš¾åº¦çº§åˆ«
                isWaveActive: false // è·Ÿè¸ªå½“å‰æ˜¯å¦æœ‰æ³¢æ¬¡åœ¨è¿›è¡Œä¸­
            };
            
            // é˜²å¾¡å¡”ç±»å‹æ•°æ®
            const towerTypes = {
                archer: {
                    name: "å¼“ç®­å¡”",
                    cost: 70,
                    range: 120,
                    damage: 15,
                    cooldown: 1000,
                    color: "#4CAF50",
                    maxLevel: 4,
                    icon: "ğŸ¹",
                    description: "åŸºç¡€è¿œç¨‹é˜²å¾¡å¡”ï¼Œå¹³è¡¡çš„ä¼¤å®³å’Œå°„ç¨‹ï¼Œæ€§ä»·æ¯”é«˜ã€‚"
                },
                cannon: {
                    name: "ç«ç‚®å¡”",
                    cost: 120,
                    range: 100,
                    damage: 30,
                    cooldown: 2000,
                    color: "#FF5722",
                    maxLevel: 4,
                    icon: "ğŸ’£",
                    splashRadius: 80, // çˆ†ç‚¸èŒƒå›´
                    splashDamage: 30, // æº…å°„ä¼¤å®³
                    description: "é«˜ä¼¤å®³èŒƒå›´æ”»å‡»ï¼Œå¯¹ä»˜ç¾¤ä½“æ•Œäººæ•ˆæœæ˜¾è‘—ï¼Œä½†æ”»å‡»é€Ÿåº¦è¾ƒæ…¢ã€‚"
                },
                mage: {
                    name: "æ³•å¸ˆå¡”",
                    cost: 150,
                    range: 140,
                    damage: 5,
                    cooldown: 150,
                    color: "#9C27B0",
                    maxLevel: 4,
                    icon: "ğŸ”®",
                    description: "è¿œè·ç¦»ç²¾å‡†æ‰“å‡»ï¼Œå¯¹é«˜é­”æŠ—æ•Œäººç‰¹åˆ«æœ‰æ•ˆã€‚"
                },
                barracks: {
                    name: "å…µè¥",
                    cost: 100,
                    range: 120, // å£«å…µç´¢æ•ŒèŒƒå›´
                    cooldown: 3000,
                    color: "#2196F3",
                    maxLevel: 4,
                    icon: "ğŸ›¡ï¸",
                    description: "è®­ç»ƒæ— æ•Œå£«å…µé˜»æŒ¡æ•Œäººï¼Œå£«å…µä¼šè‡ªåŠ¨æ”»å‡»é™„è¿‘çš„æ•Œäººã€‚",
                    maxSoldiers: 3,
                    soldierDamage: 10,
                    soldierAttackSpeed: 1000,
                    soldierAttackRange: 80 // å£«å…µæ”»å‡»èŒƒå›´ï¼ˆå·²ä¿®å¤ä¸º80ï¼‰
                },
                ice: {
                    name: "å¯’å†°å¡”",
                    cost: 130,
                    range: 130,
                    damage: 10,
                    cooldown: 2000,
                    color: "#29B6F6",
                    maxLevel: 4,
                    slowEffect: 0.5, // å‡é€Ÿæ•ˆæœ
                    slowDuration: 2000, // å‡é€ŸæŒç»­æ—¶é—´
                    icon: "â„ï¸",
                    description: "å‡é€Ÿæ•Œäººç§»åŠ¨é€Ÿåº¦ï¼Œä½¿å…¶ä»–é˜²å¾¡å¡”æœ‰æ›´å¤šæ”»å‡»æ—¶é—´ã€‚"
                },
                lightning: {
                    name: "é›·ç”µå¡”",
                    cost: 180,
                    range: 150,
                    damage: 15,
                    cooldown: 2500,
                    color: "#FFEB3B",
                    maxLevel: 4,
                    chainCount: 3, // è¿é”æ•°é‡
                    chainRange: 80, // è¿é”èŒƒå›´
                    icon: "âš¡",
                    description: "é‡Šæ”¾è¿é”é—ªç”µï¼Œå¯åŒæ—¶æ”»å‡»å¤šä¸ªæ•Œäººã€‚"
                },
                missile: {
                    name: "å¯¼å¼¹å¡”",
                    cost: 200,
                    range: 140,
                    damage: 80,
                    cooldown: 3000,
                    color: "#FF9800",
                    maxLevel: 4,
                    splashRadius: 100, // çˆ†ç‚¸èŒƒå›´
                    splashDamage: 65, // æº…å°„ä¼¤å®³
                    icon: "ğŸš€",
                    description: "å‘å°„å¯¼å¼¹é€ æˆèŒƒå›´çˆ†ç‚¸ä¼¤å®³ï¼Œå¯¹ç¾¤ä½“æ•Œäººæ•ˆæœæ˜¾è‘—ã€‚"
                },
                poison: {
                    name: "æ¯’å¡”",
                    cost: 160,
                    range: 110,
                    damage: 15, // æ¯ç§’ä¼¤å®³
                    cooldown: 1600,
                    color: "#66BB6A",
                    maxLevel: 4,
                    poisonDuration: 4000, // ä¸­æ¯’æŒç»­æ—¶é—´
                    slowEffect: 0.3, // å‡é€Ÿæ•ˆæœ
                    percentDamage: 0.05, // ç™¾åˆ†æ¯”ä¼¤å®³
                    icon: "â˜ ï¸",
                    description: "é€ æˆæŒç»­ä¼¤å®³å¹¶å‡é€Ÿæ•Œäººï¼Œå¯¹é«˜è¡€é‡æ•Œäººç‰¹åˆ«æœ‰æ•ˆã€‚"
                },
				// æ–°å¢ï¼šæ¿€å…‰å¡”
                laser: {
                    name: "æ¿€å…‰å¡”",
                    cost: 220,
                    range: 200,
                    damage: 35, // æ¯ç§’ä¼¤å®³
                    cooldown: 0, // æŒç»­æ”»å‡»
                    color: "#FF5252",
                    maxLevel: 4,
                    icon: "ğŸ”¦",
                    description: "æŒç»­æ¿€å…‰æ”»å‡»ï¼Œå¯¹å•ä¸ªç›®æ ‡é€ æˆæŒç»­é«˜ä¼¤å®³ã€‚"
                },
                // æ–°å¢ï¼šæ ¸å¼¹å¡”
                nuke: {
                    name: "æ²¡å…³å°±æ˜¯å¼€äº†ï¼Ÿ",
                    cost: 1,
                    range: 9999, // å…¨å±
                    damage: 9999, // ç§’æ€
                    cooldown: 3,
                    color: "#00E676",
                    maxLevel: 1, // ä¸èƒ½å‡çº§
                    icon: "â˜¢ï¸",
                    description: "å‘å°„æ ¸å¼¹ï¼Œå¯¹æ‰€æœ‰æ•Œäººé€ æˆæ¯ç­æ€§ä¼¤å®³ã€‚"
                },
                // æ–°å¢ï¼šè“„èƒ½å¡”ï¼ˆæ”»å‡»æ—¶é—´è¶Šé•¿ä¼¤å®³è¶Šé«˜ï¼‰
                energizer: {
                    name: "è“„èƒ½å¡”",
                    cost: 280,
                    range: 130,
                    damage: 20, // åŸºç¡€ä¼¤å®³
                    maxDamage: 100, // æœ€å¤§ä¼¤å®³
                    cooldown: 1000,
                    color: "#FF4081",
                    maxLevel: 4,
                    icon: "âš¡",
                    description: "å¯¹åŒä¸€ç›®æ ‡è¿ç»­æ”»å‡»æ—¶ä¼¤å®³é€æ¸å¢åŠ ã€‚"
                },
				
                // æ–°å¢ï¼šå……èƒ½ç¦»å­ç‚®
                ion: {
                    name: "å……èƒ½ç¦»å­ç‚®",
                    cost: 200,
                    range: 150,
                    damage: 30,
                    cooldown: 3000,
                    color: "#9C27B0",
                    maxLevel: 4,
                    splashRadius: 100,
                    splashDamage: 30,
                    icon: "ğŸ”‹",
                    description: "å‘å°„é«˜èƒ½ç¦»å­æŸï¼Œé€ æˆèŒƒå›´ä¼¤å®³ã€‚"
                },
                // æ–°å¢ï¼šå…‰æ£±å¡”
                prism: {
                    name: "å…‰æ£±å¡”",
                    cost: 350,
                    range: 140,
                    damage: 50,
                    cooldown: 2500,
                    color: "#FF5252",
                    maxLevel: 4,
                    bounceCount: 4,
                    bounceRange: 80,
                    bounceDecay: 0.3,
                    icon: "âœ¨",
                    description: "å‘å°„å¯æŠ˜å°„çš„å…‰æŸï¼Œæ”»å‡»å¤šä¸ªæ•Œäººã€‚"
                },
                // æ–°å¢ï¼šå°¤é‡Œå¡”
                yuri: {
                    name: "å°¤é‡Œå¡”",
                    cost: 100,
                    range: 120,
                    controlDuration: 5000,
                    cooldown: 8000,
                    color: "#00BCD4",
                    maxLevel: 4,
                    icon: "ğŸ§ ",
                    description: "æ§åˆ¶æ•Œäººä½¿å…¶å€’æˆˆæ”»å‡»å…¶ä»–æ•Œäººã€‚"
                }
            };
            
            // æ•Œäººç±»å‹æ•°æ®
            const enemyTypes = [
                { 
                    type: "goblin", 
                    name: "å“¥å¸ƒæ—",
                    health: 50, 
                    speed: 1.0, 
                    reward: 15, 
                    color: "#FF5252",
                    icon: "ğŸ‘¾",
                    description: "åŸºç¡€æ•Œäººï¼Œæ•°é‡ä¼—å¤šä½†ç”Ÿå‘½å€¼è¾ƒä½ã€‚"
                },
                { 
                    type: "orc", 
                    name: "å…½äºº",
                    health: 100, 
                    speed: 0.8, 
                    reward: 25, 
                    color: "#E91E63",
                    icon: "ğŸ‘¹",
                    description: "ä¸­ç­‰ç”Ÿå‘½å€¼ï¼Œå¯¹ç‰©ç†æ”»å‡»æœ‰ä¸€å®šæŠ—æ€§ã€‚"
                },
                { 
                    type: "ogre", 
                    name: "é£Ÿäººé­”",
                    health: 1000, 
                    speed: 0.5, 
                    reward: 40, 
                    color: "#9C27B0",
                    icon: "ğŸ‘»",
                    description: "é«˜ç”Ÿå‘½å€¼ï¼Œç§»åŠ¨ç¼“æ…¢ä½†ç ´ååŠ›å¼ºã€‚"
                },
                { 
                    type: "knight", 
                    name: "éª‘å£«",
                    health: 550, 
                    speed: 0.7, 
                    reward: 35, 
                    color: "#5C6BC0",
                    icon: "ğŸ¤´",
                    description: "é«˜æŠ¤ç”²ï¼Œå¯¹ç‰©ç†æ”»å‡»æœ‰è¾ƒå¼ºæŠµæŠ—åŠ›ã€‚"
                },
                { 
                    type: "flying", 
                    name: "é£è¡Œæ¶é­”",
                    health: 90, 
                    speed: 1.5, 
                    reward: 30, 
                    color: "#26A69A", 
                    flying: true,
                    icon: "ğŸ¦‡",
                    description: "é«˜é€Ÿé£è¡Œå•ä½ï¼Œå¯ç»•è¿‡éƒ¨åˆ†é˜²å¾¡å¡”ã€‚"
                },
                { 
                    type: "boss", 
                    name: "æš—å½±é¢†ä¸»",
                    health: 8000, 
                    speed: 0.4, 
                    reward: 150, 
                    color: "#D32F2F", 
                    size: 25,
                    icon: "ğŸ‘‘",
                    description: "ç»ˆæBossï¼Œéœ€è¦é›†ä¸­ç«åŠ›æ‰èƒ½å‡»è´¥ã€‚"
                }
            ];
            
            // å…³å¡é…ç½®
            const levels = {
                1: {
                    name: "æ£®æ—å…³å¡",
                    path: [
                        { x: -30, y: 250 },
                        { x: 150, y: 250 },
                        { x: 150, y: 100 },
                        { x: 350, y: 100 },
                        { x: 350, y: 350 },
                        { x: 550, y: 350 },
                        { x: 550, y: 150 },
                        { x: 750, y: 150 },
                        { x: 850, y: 150 }
                    ],
                    waves: 10,
                    enemyConfig: [
                        { type: "goblin", count: 10, delay: 1000 },
                        { type: "goblin", count: 15, delay: 800 },
                        { type: "orc", count: 8, delay: 1000 },
                        { type: "orc", count: 12, delay: 800 },
                        { type: "goblin", count: 20, delay: 700 },
                        { type: "orc", count: 15, delay: 800 },
                        { type: "ogre", count: 4, delay: 1500 },
                        { type: "flying", count: 8, delay: 1000 },
                        { type: "knight", count: 8, delay: 900 },
                        { type: "boss", count: 1, delay: 2000 }
                    ],
                    description: "æ–°æ‰‹å‹å¥½å…³å¡ï¼Œè·¯å¾„ç®€å•ï¼Œæ•Œäººå¼ºåº¦è¾ƒä½ã€‚"
                },
                2: {
                    name: "æ²™æ¼ å…³å¡",
                    path: [
                        { x: -30, y: 150 },
                        { x: 200, y: 150 },
                        { x: 200, y: 350 },
                        { x: 400, y: 350 },
                        { x: 400, y: 100 },
                        { x: 600, y: 100 },
                        { x: 600, y: 300 },
                        { x: 850, y: 300 }
                    ],
                    waves: 10,
                    enemyConfig: [
                        { type: "goblin", count: 15, delay: 1000 },
                        { type: "orc", count: 12, delay: 1000 },
                        { type: "flying", count: 10, delay: 800 },
                        { type: "orc", count: 18, delay: 700 },
                        { type: "ogre", count: 6, delay: 1200 },
                        { type: "flying", count: 12, delay: 700 },
                        { type: "knight", count: 10, delay: 900 },
                        { type: "ogre", count: 10, delay: 1000 },
                        { type: "flying", count: 15, delay: 600 },
                        { type: "boss", count: 2, delay: 2000 }
                    ],
                    description: "ä¸­ç­‰éš¾åº¦å…³å¡ï¼Œè·¯å¾„å¤æ‚ï¼Œé£è¡Œæ•Œäººå¢å¤šã€‚"
                },
                3: {
                    name: "é›ªå±±å…³å¡",
                    path: [
                        { x: -30, y: 250 },
                        { x: 100, y: 250 },
                        { x: 100, y: 100 },
                        { x: 300, y: 100 },
                        { x: 300, y: 400 },
                        { x: 500, y: 400 },
                        { x: 500, y: 200 },
                        { x: 700, y: 200 },
                        { x: 700, y: 350 },
                        { x: 850, y: 350 }
                    ],
                    waves: 10,
                    enemyConfig: [
                        { type: "orc", count: 15, delay: 800 },
                        { type: "flying", count: 12, delay: 700 },
                        { type: "knight", count: 12, delay: 800 },
                        { type: "ogre", count: 6, delay: 1000 },
                        { type: "flying", count: 18, delay: 600 },
                        { type: "knight", count: 15, delay: 700 },
                        { type: "ogre", count: 10, delay: 900 },
                        { type: "boss", count: 2, delay: 1500 },
                        { type: "flying", count: 20, delay: 500 },
                        { type: "boss", count: 3, delay: 2000 }
                    ],
                    description: "å›°éš¾å…³å¡ï¼Œæ•Œäººå¼ºåº¦é«˜ï¼Œè·¯å¾„æ›²æŠ˜å¤šå˜ã€‚"
                },
                4: {
                    name: "æœ€ç»ˆå…³å¡",
                    path: [
                        { x: -30, y: 100 },
                        { x: 150, y: 100 },
                        { x: 150, y: 400 },
                        { x: 350, y: 400 },
                        { x: 350, y: 100 },
                        { x: 550, y: 100 },
                        { x: 550, y: 400 },
                        { x: 750, y: 400 },
                        { x: 850, y: 400 }
                    ],
                    waves: 10,
                    enemyConfig: [
                        { type: "goblin", count: 20, delay: 700 },
                        { type: "orc", count: 18, delay: 700 },
                        { type: "flying", count: 15, delay: 600 },
                        { type: "knight", count: 15, delay: 700 },
                        { type: "ogre", count: 8, delay: 800 },
                        { type: "flying", count: 20, delay: 500 },
                        { type: "knight", count: 20, delay: 600 },
                        { type: "ogre", count: 15, delay: 700 },
                        { type: "boss", count: 4, delay: 1200 },
                        { type: "boss", count: 5, delay: 1000 }
                    ],
                    description: "ç»ˆææŒ‘æˆ˜ï¼ŒåŒ…å«å¤§é‡é«˜ç”Ÿå‘½å€¼æ•Œäººå’Œå¤šä¸ªBossã€‚"
                }
            };
            
            // æ˜¾ç¤ºçŠ¶æ€æ¶ˆæ¯
            function showStatusMessage(text, color = "#FFD700", duration = 2000) {
                statusMessage.textContent = text;
                statusMessage.style.color = color;
                statusMessage.style.opacity = 1;
                
                setTimeout(() => {
                    statusMessage.style.opacity = 0;
                }, duration);
            }
            
            // åˆå§‹åŒ–å›¾é‰´
            function initEncyclopedia() {
                // æ·»åŠ é˜²å¾¡å¡”
                towersTab.innerHTML = '';
                for (const key in towerTypes) {
                    const tower = towerTypes[key];
                    const item = document.createElement('div');
                    item.className = 'encyclopedia-item';
                    
                    let stats = `<div>ä»·æ ¼: ${tower.cost}</div>
                                 <div>ä¼¤å®³: ${tower.damage || 'ç‰¹æ®Š'}</div>
                                 <div>èŒƒå›´: ${tower.range}</div>
                                 <div>å†·å´: ${tower.cooldown/1000}ç§’</div>
                                 <div>æœ€å¤§ç­‰çº§: ${tower.maxLevel}</div>`;
                    
                    if (tower.slowEffect) {
                        stats += `<div>å‡é€Ÿ: ${(1 - tower.slowEffect) * 100}%</div>`;
                    }
                    if (tower.poisonDuration) {
                        stats += `<div>ä¸­æ¯’æŒç»­æ—¶é—´: ${tower.poisonDuration/1000}ç§’</div>`;
                    }
                    if (tower.percentDamage) {
                        stats += `<div>ç™¾åˆ†æ¯”ä¼¤å®³: ${tower.percentDamage * 100}%</div>`;
                    }
                    if (tower.splashRadius) {
                        stats += `<div>çˆ†ç‚¸èŒƒå›´: ${tower.splashRadius}</div>
                                  <div>æº…å°„ä¼¤å®³: ${tower.splashDamage}</div>`;
                    }
                    if (tower.chainCount) {
                        stats += `<div>è¿é”æ•°é‡: ${tower.chainCount}</div>
                                  <div>è¿é”èŒƒå›´: ${tower.chainRange}</div>`;
                    }
                    if (tower.soldierDamage) {
                        stats += `<div>å£«å…µä¼¤å®³: ${tower.soldierDamage}</div>
                                  <div>å£«å…µæ”»å‡»èŒƒå›´: ${tower.soldierAttackRange}</div>
                                  <div>æœ€å¤§å£«å…µ: ${tower.maxSoldiers}</div>`;
                    }
                    if (tower.bounceCount) {
                        stats += `<div>æŠ˜å°„æ¬¡æ•°: ${tower.bounceCount}</div>
                                  <div>æŠ˜å°„è¡°å‡: ${tower.bounceDecay * 100}%</div>`;
                    }
                    if (tower.controlDuration) {
                        stats += `<div>æ§åˆ¶æ—¶é—´: ${tower.controlDuration/1000}ç§’</div>`;
                    }
                    
                    item.innerHTML = `
                        <div class="encyclopedia-icon">${tower.icon}</div>
                        <div class="encyclopedia-name">${tower.name}</div>
                        <div class="encyclopedia-stats">
                            ${stats}
                        </div>
                        <div style="margin-top:10px;font-size:0.9rem;color:#ddd;">${tower.description}</div>
                    `;
                    
                    towersTab.appendChild(item);
                }
                
                // æ·»åŠ æ•Œäºº
                enemiesTab.innerHTML = '';
                for (const enemy of enemyTypes) {
                    const item = document.createElement('div');
                    item.className = 'encyclopedia-item';
                    
                    const stats = `<div>ç”Ÿå‘½å€¼: ${enemy.health}</div>
                                  <div>é€Ÿåº¦: ${enemy.speed}</div>
                                  <div>å¥–åŠ±: ${enemy.reward}</div>
                                  ${enemy.flying ? '<div>ç±»å‹: é£è¡Œ</div>' : ''}`;
                    
                    item.innerHTML = `
                        <div class="encyclopedia-icon">${enemy.icon}</div>
                        <div class="encyclopedia-name">${enemy.name}</div>
                        <div class="encyclopedia-stats">
                            ${stats}
                        </div>
                        <div style="margin-top:10px;font-size:0.9rem;color:#ddd;">${enemy.description}</div>
                    `;
                    
                    enemiesTab.appendChild(item);
                }
                
                // æ·»åŠ å…³å¡ä¿¡æ¯
                levelsTab.innerHTML = '';
                for (const level in levels) {
                    const levelData = levels[level];
                    const item = document.createElement('div');
                    item.className = 'encyclopedia-item';
                    
                    const stats = `<div>æ³¢æ•°: ${levelData.waves}</div>
                                  <div>éš¾åº¦: ${level}</div>
                                  <div>æ•Œäººç±»å‹: ${levelData.enemyConfig.map(e => e.type).filter((v,i,a)=>a.indexOf(v)===i).join(', ')}</div>`;
                    
                    item.innerHTML = `
                        <div class="encyclopedia-icon">${level == 1 ? 'ğŸŒ²' : level == 2 ? 'ğŸœï¸' : level == 3 ? 'ğŸ”ï¸' : 'ğŸ°'}</div>
                        <div class="encyclopedia-name">${levelData.name}</div>
                        <div class="encyclopedia-stats">
                            ${stats}
                        </div>
                        <div style="margin-top:10px;font-size:0.9rem;color:#ddd;">${levelData.description}</div>
                    `;
                    
                    levelsTab.appendChild(item);
                }
            }
            
            // åˆå§‹åŒ–è·¯å¾„ç‚¹
            function initPath() {
                const level = levels[gameState.currentLevel];
                gameState.path = level.path;
                gameState.maxWave = level.waves;
                maxWaveDisplay.textContent = level.waves;
                levelDisplay.textContent = gameState.currentLevel;
            }
            
            // åˆ›å»ºæ•Œäºº
            function createEnemy(typeName) {
                const type = enemyTypes.find(e => e.type === typeName);
                if (!type) return;
                
                // æ ¹æ®éš¾åº¦è°ƒæ•´æ•Œäººå±æ€§
                const healthMultiplier = 1 + (gameState.difficulty - 1) * 0.3;
                const speedMultiplier = 1 + (gameState.difficulty - 1) * 0.05;
                
                const enemy = {
                    x: gameState.path[0].x,
                    y: gameState.path[0].y,
                    pathIndex: 0,
                    health: type.health * healthMultiplier,
                    maxHealth: type.health * healthMultiplier,
                    speed: type.speed * speedMultiplier,
                    reward: type.reward,
                    color: type.color,
                    type: type.type,
                    name: type.name,
                    size: type.size || 15,
                    flying: type.flying || false,
                    effects: [],
                    isAttacking: false,
                    currentSpeed: type.speed * speedMultiplier,
                    isControlled: false, // æ˜¯å¦è¢«å°¤é‡Œå¡”æ§åˆ¶
                    controlledBy: null, // è¢«å“ªä¸ªå¡”æ§åˆ¶
                    controlEndTime: 0 // æ§åˆ¶ç»“æŸæ—¶é—´
                };
                
                gameState.enemies.push(enemy);
            }
            
            // åˆ›å»ºé˜²å¾¡å¡”
            function createTower(x, y, type) {
                const towerData = towerTypes[type];
                
                const tower = {
                    x: x,
                    y: y,
                    type: type,
                    range: towerData.range,
                    damage: towerData.damage,
                    cooldown: towerData.cooldown,
                    lastShot: 0,
                    color: towerData.color,
                    level: 1,
                    maxLevel: towerData.maxLevel
                };
                
                // å…µè¥ç‰¹æ®Šå±æ€§
                if (type === 'barracks') {
                    tower.maxSoldiers = towerData.maxSoldiers;
                    tower.soldiers = [];
                    tower.lastSpawn = 0;
                    tower.soldierDamage = towerData.soldierDamage;
                    tower.soldierAttackSpeed = towerData.soldierAttackSpeed;
                    tower.soldierAttackRange = towerData.soldierAttackRange;
                }
                
                // ç«ç‚®å¡”ç‰¹æ®Šå±æ€§
                if (type === 'cannon') {
                    tower.splashRadius = towerData.splashRadius;
                    tower.splashDamage = towerData.splashDamage;
                }
                
                // é›·ç”µå¡”ç‰¹æ®Šå±æ€§
                if (type === 'lightning') {
                    tower.chainCount = towerData.chainCount;
                    tower.chainRange = towerData.chainRange;
                }
                
                // å¯¼å¼¹å¡”ç‰¹æ®Šå±æ€§
                if (type === 'missile') {
                    tower.splashRadius = towerData.splashRadius;
                    tower.splashDamage = towerData.splashDamage;
                }
                
                // æ¯’å¡”ç‰¹æ®Šå±æ€§
                if (type === 'poison') {
                    tower.poisonDuration = towerData.poisonDuration;
                    tower.slowEffect = towerData.slowEffect;
                    tower.percentDamage = towerData.percentDamage;
                }
                
                // ç¦»å­ç‚®ç‰¹æ®Šå±æ€§
                if (type === 'ion') {
                    tower.splashRadius = towerData.splashRadius;
                    tower.splashDamage = towerData.splashDamage;
                    tower.charge = 0; // å……èƒ½è¿›åº¦
                    tower.maxCharge = 100; // æœ€å¤§å……èƒ½
                }
                
                // å…‰æ£±å¡”ç‰¹æ®Šå±æ€§
                if (type === 'prism') {
                    tower.bounceCount = towerData.bounceCount;
                    tower.bounceRange = towerData.bounceRange;
                    tower.bounceDecay = towerData.bounceDecay;
                }
                
                // å°¤é‡Œå¡”ç‰¹æ®Šå±æ€§
                if (type === 'yuri') {
                    tower.controlDuration = towerData.controlDuration;
                    tower.controlledEnemies = []; // å½“å‰æ§åˆ¶çš„æ•Œäºº
                }
                
				// æ¿€å…‰å¡”ç‰¹æ®Šå±æ€§
                if (type === 'laser') {
                    tower.target = null;
                    tower.attackTime = 0;
                }
                
                // æ ¸å¼¹å¡”ç‰¹æ®Šå±æ€§
                if (type === 'nuke') {
                    tower.lastNukeTime = 0;
                }
                
                // è“„èƒ½å¡”ç‰¹æ®Šå±æ€§
                if (type === 'energizer') {
                    tower.target = null;
                    tower.combo = 0;
                    tower.maxCombo = 10;
                    tower.maxDamage = towerData.maxDamage;
                }
				
                gameState.towers.push(tower);
                gameState.gold -= towerData.cost;
                updateStats();
                
                showStatusMessage(`${towerData.name}å·²å»ºé€ !`, "#4CAF50");
            }
            
            // å‡çº§é˜²å¾¡å¡”
            function upgradeTower() {
                if (!gameState.selectedTower) return;
                if (gameState.gold < 100) return;
                if (gameState.selectedTower.level >= gameState.selectedTower.maxLevel) return;
                
                // åŸºç¡€å±æ€§å‡çº§
                gameState.selectedTower.damage += gameState.selectedTower.type === "poison" ? 4 : 10;
                gameState.selectedTower.range += 15;
                gameState.selectedTower.level++;
                
                // å…µè¥ç‰¹æ®Šå‡çº§ï¼ˆä¿®å¤ï¼šç‹¬ç«‹å‡çº§ï¼‰
                if (gameState.selectedTower.type === "barracks") {
                    gameState.selectedTower.soldierAttackRange += 10; // å¢åŠ å£«å…µæ”»å‡»èŒƒå›´
                    gameState.selectedTower.range += 15; // å¢åŠ å…µè¥ç´¢æ•ŒèŒƒå›´
                    gameState.selectedTower.soldierDamage += 5; // å¢åŠ å£«å…µä¼¤å®³
                    gameState.selectedTower.maxSoldiers++; // å¢åŠ æœ€å¤§å£«å…µæ•°
                }
                
                // ç«ç‚®å¡”ç‰¹æ®Šå‡çº§
                if (gameState.selectedTower.type === "cannon") {
                    gameState.selectedTower.splashRadius += 10;
                    gameState.selectedTower.splashDamage += 5;
                }
                
                // é›·ç”µå¡”ç‰¹æ®Šå‡çº§
                if (gameState.selectedTower.type === "lightning") {
                    gameState.selectedTower.chainCount++;
                    gameState.selectedTower.chainRange += 10;
                }
                
                // å¯¼å¼¹å¡”ç‰¹æ®Šå‡çº§
                if (gameState.selectedTower.type === "missile") {
                    gameState.selectedTower.splashRadius += 10;
                    gameState.selectedTower.splashDamage += 5;
                }
                
                // æ¯’å¡”ç‰¹æ®Šå‡çº§
                if (gameState.selectedTower.type === "poison") {
                    gameState.selectedTower.damage += 4;
                    gameState.selectedTower.slowEffect *= 0.9;
                    gameState.selectedTower.percentDamage += 0.005;
                }
                
                // ç¦»å­ç‚®ç‰¹æ®Šå‡çº§
                if (gameState.selectedTower.type === "ion") {
                    gameState.selectedTower.damage += 15;
                    gameState.selectedTower.splashRadius += 10;
                    gameState.selectedTower.splashDamage += 10;
                }
                
				// æ¿€å…‰å¡”ç‰¹æ®Šå‡çº§
                if (gameState.selectedTower.type === "laser") {
                    gameState.selectedTower.damage += 8;
                }
                
                // è“„èƒ½å¡”ç‰¹æ®Šå‡çº§
                if (gameState.selectedTower.type === "energizer") {
                    gameState.selectedTower.damage += 5;
                    gameState.selectedTower.maxDamage += 20;
                    gameState.selectedTower.maxCombo += 2;
                }
				
                // å…‰æ£±å¡”ç‰¹æ®Šå‡çº§
                if (gameState.selectedTower.type === "prism") {
                    gameState.selectedTower.damage += 10;
                    gameState.selectedTower.bounceCount++;
                    gameState.selectedTower.bounceRange += 10;
                    gameState.selectedTower.bounceDecay *= 0.9;
                }
                
                // å°¤é‡Œå¡”ç‰¹æ®Šå‡çº§
                if (gameState.selectedTower.type === "yuri") {
                    gameState.selectedTower.controlDuration += 1000;
                    gameState.selectedTower.cooldown -= 500;
                }
                
                gameState.gold -= 100;
                updateStats();
                
                // æ·»åŠ å‡çº§ç‰¹æ•ˆ
                createUpgradeEffect(gameState.selectedTower.x, gameState.selectedTower.y);
                
                showStatusMessage(`å‡çº§æˆåŠŸ! Lv.${gameState.selectedTower.level}`, "#29B6F6");
            }
            
            // åˆ›å»ºå‡çº§ç‰¹æ•ˆ
            function createUpgradeEffect(x, y) {
                const effect = {
                    type: 'upgrade',
                    x: x,
                    y: y,
                    radius: 20,
                    color: "#FFD700",
                    duration: 1000,
                    startTime: Date.now(),
                    particles: []
                };
                
                // åˆ›å»ºç²’å­
                for (let i = 0; i < 20; i++) {
                    effect.particles.push({
                        angle: Math.random() * Math.PI * 2,
                        distance: Math.random() * 20,
                        speed: 0.5 + Math.random() * 1,
                        size: 2 + Math.random() * 4,
                        color: `hsl(${Math.random() * 60 + 40}, 100%, 60%)`
                    });
                }
                
                gameState.effects.push(effect);
            }
            
            // å…µè¥ç”Ÿæˆå£«å…µ
            function spawnSoldier(barracks) {
                if (barracks.soldiers.length >= barracks.maxSoldiers) return;
                
                // åœ¨å…µè¥å‘¨å›´ç”Ÿæˆå£«å…µ
                const angle = Math.random() * Math.PI * 2;
                const distance = 30;
                const soldier = {
                    x: barracks.x + Math.cos(angle) * distance,
                    y: barracks.y + Math.sin(angle) * distance,
                    damage: barracks.soldierDamage,
                    attackSpeed: barracks.soldierAttackSpeed,
                    range: barracks.soldierAttackRange, // å£«å…µæ”»å‡»èŒƒå›´
                    sightRange: barracks.range, // å£«å…µç´¢æ•ŒèŒƒå›´
                    lastAttack: 0,
                    target: null,
                    barracks: barracks,
                    color: "#2196F3"
                };
                
                // å£«å…µç”Ÿæˆåç«‹å³å¯»æ‰¾ç›®æ ‡ï¼ˆä¿®å¤ç¬¬ä¸€ä¸ªå…µä¸ç´¢æ•Œé—®é¢˜ï¼‰
                let minDist = soldier.sightRange;
                soldier.target = null;
                
                for (const enemy of gameState.enemies) {
                    const dx = enemy.x - soldier.x;
                    const dy = enemy.y - soldier.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < minDist) {
                        minDist = dist;
                        soldier.target = enemy;
                    }
                }
                
                barracks.soldiers.push(soldier);
            }
            
            // æ›´æ–°å£«å…µçŠ¶æ€
            function updateSoldiers(timestamp) {
                for (const tower of gameState.towers) {
                    if (tower.type !== 'barracks') continue;
                    
                    // å®šæœŸç”Ÿæˆå£«å…µ
                    if (timestamp - tower.lastSpawn > tower.cooldown) {
                        spawnSoldier(tower);
                        tower.lastSpawn = timestamp;
                    }
                    
                    // æ›´æ–°å£«å…µè¡Œä¸º
                    for (const soldier of tower.soldiers) {
                        // å¯»æ‰¾ç›®æ ‡æ•Œäºº
                        if (!soldier.target || soldier.target.health <= 0) {
                            let minDist = soldier.sightRange; // ä½¿ç”¨ç´¢æ•ŒèŒƒå›´
                            soldier.target = null;
                            
                            for (const enemy of gameState.enemies) {
                                const dx = enemy.x - soldier.x;
                                const dy = enemy.y - soldier.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                
                                if (dist < minDist) {
                                    minDist = dist;
                                    soldier.target = enemy;
                                }
                            }
                        }
                        
                        // æ”»å‡»ç›®æ ‡
                        if (soldier.target && timestamp - soldier.lastAttack > soldier.attackSpeed) {
                            soldier.target.health -= soldier.damage;
                            soldier.lastAttack = timestamp;
                            
                            // åˆ›å»ºæ”»å‡»æ•ˆæœ
                            gameState.effects.push({
                                type: 'melee',
                                x: soldier.target.x,
                                y: soldier.target.y,
                                radius: 10,
                                color: "#FF5252",
                                duration: 200,
                                startTime: timestamp
                            });
                        }
                        
                        // å‘ç›®æ ‡ç§»åŠ¨
                        if (soldier.target) {
                            const dx = soldier.target.x - soldier.x;
                            const dy = soldier.target.y - soldier.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist > soldier.range * 0.8) {
                                soldier.x += (dx / dist) * 0.5;
                                soldier.y += (dy / dist) * 0.5;
                            }
                        } else {
                            // è¿”å›å…µè¥
                            const dx = tower.x - soldier.x;
                            const dy = tower.y - soldier.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist > 30) {
                                soldier.x += (dx / dist) * 0.3;
                                soldier.y += (dy / dist) * 0.3;
                            }
                        }
                    }
                }
            }
            
            // åº”ç”¨æ•ˆæœï¼ˆå‡é€Ÿã€ä¸­æ¯’ï¼‰
            function applyEffect(enemy, effectType, tower) {
                // æ£€æŸ¥æ˜¯å¦å·²æœ‰ç›¸åŒæ•ˆæœ
                const existingEffect = enemy.effects.find(e => e.type === effectType);
                if (existingEffect) {
                    existingEffect.startTime = Date.now();
                    return;
                }
                
                // æ·»åŠ æ–°æ•ˆæœ
                enemy.effects.push({
                    type: effectType,
                    startTime: Date.now(),
                    duration: towerTypes[tower.type][effectType === "slow" ? "slowDuration" : "poisonDuration"],
                    value: effectType === "slow" ? towerTypes[tower.type].slowEffect : tower.damage,
                    percentDamage: tower.percentDamage // æ¯’å¡”ç™¾åˆ†æ¯”ä¼¤å®³
                });
            }
            
            // æ›´æ–°æ•Œäººæ•ˆæœ
            function updateEnemyEffects(timestamp) {
                for (const enemy of gameState.enemies) {
                    // ç§»é™¤è¿‡æœŸæ•ˆæœ
                    enemy.effects = enemy.effects.filter(effect => {
                        return timestamp - effect.startTime < effect.duration;
                    });
                    
                    // åº”ç”¨æ•ˆæœ
                    let speedMultiplier = 1;
                    let poisonDamage = 0;
                    
                    for (const effect of enemy.effects) {
                        if (effect.type === "slow") {
                            speedMultiplier = Math.min(speedMultiplier, effect.value);
                        } else if (effect.type === "poison") {
                            // å›ºå®šä¼¤å®³ + ç™¾åˆ†æ¯”ä¼¤å®³
                            poisonDamage += (effect.value + enemy.maxHealth * effect.percentDamage) / 60; // æ¯å¸§ä¼¤å®³
                        }
                    }
                    
                    enemy.currentSpeed = enemy.speed * speedMultiplier;
                    
                    // åº”ç”¨ä¸­æ¯’ä¼¤å®³
                    if (poisonDamage > 0) {
                        enemy.health -= poisonDamage;
                        if (enemy.health <= 0) {
                            gameState.gold += enemy.reward;
                        }
                    }
                    
                    // æ£€æŸ¥æ§åˆ¶æ•ˆæœ
                    if (enemy.isControlled && timestamp > enemy.controlEndTime) {
                        enemy.isControlled = false;
                        enemy.controlledBy = null;
                    }
                }
            }
            
            // æ›´æ–°æ•Œäººä½ç½®
            function updateEnemies(deltaTime, timestamp) {
                for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                    const enemy = gameState.enemies[i];
                    
                    // æ•Œäººåˆ°è¾¾ç»ˆç‚¹
                    if (enemy.pathIndex >= gameState.path.length - 1) {
                        gameState.lives--;
                        gameState.enemies.splice(i, 1);
                        
                        if (gameState.lives <= 0) {
                            gameState.gameOver = true;
                            gameState.gameRunning = false;
                            showStatusMessage("æ¸¸æˆç»“æŸ! åŸå ¡è¢«æ”»é™·", "#F44336", 3000);
                            return;
                        }
                        continue;
                    }
                    
                    // æ•Œäººæ­»äº¡
                    if (enemy.health <= 0) {
                        gameState.gold += enemy.reward;
                        
                        // æ·»åŠ æ­»äº¡ç‰¹æ•ˆ
                        gameState.effects.push({
                            type: 'death',
                            x: enemy.x,
                            y: enemy.y,
                            radius: enemy.size,
                            color: enemy.color,
                            duration: 500,
                            startTime: Date.now()
                        });
                        
                        gameState.enemies.splice(i, 1);
                        continue;
                    }
                    
                    // è¢«æ§åˆ¶çš„æ•Œäººè¡Œä¸º
                    if (enemy.isControlled) {
                        // è¢«æ§åˆ¶çš„æ•Œäººä¼šæ”»å‡»å…¶ä»–æ•Œäºº
                        if (!enemy.target || enemy.target.health <= 0) {
                            let minDist = enemy.size * 10;
                            enemy.target = null;
                            
                            for (const otherEnemy of gameState.enemies) {
                                if (otherEnemy === enemy || otherEnemy.isControlled) continue;
                                
                                const dx = otherEnemy.x - enemy.x;
                                const dy = otherEnemy.y - enemy.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                
                                if (dist < minDist) {
                                    minDist = dist;
                                    enemy.target = otherEnemy;
                                }
                            }
                        }
                        
                        // æ”»å‡»ç›®æ ‡
                        if (enemy.target && timestamp - enemy.lastAttack > 1000) {
                            enemy.target.health -= 10;
                            enemy.lastAttack = timestamp;
                            
                            // åˆ›å»ºæ”»å‡»æ•ˆæœ
                            gameState.effects.push({
                                type: 'melee',
                                x: enemy.target.x,
                                y: enemy.target.y,
                                radius: 10,
                                color: "#00BCD4",
                                duration: 200,
                                startTime: timestamp
                            });
                        }
                        
                        // å‘ç›®æ ‡ç§»åŠ¨
                        if (enemy.target) {
                            const dx = enemy.target.x - enemy.x;
                            const dy = enemy.target.y - enemy.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist > enemy.size * 2) {
                                enemy.x += (dx / dist) * enemy.currentSpeed * deltaTime;
                                enemy.y += (dy / dist) * enemy.currentSpeed * deltaTime;
                            }
                        }
                        
                        continue;
                    }
                    
                    // ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªè·¯å¾„ç‚¹
                    const targetX = gameState.path[enemy.pathIndex + 1].x;
                    const targetY = gameState.path[enemy.pathIndex + 1].y;
                    
                    const dx = targetX - enemy.x;
                    const dy = targetY - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < enemy.currentSpeed * deltaTime) {
                        // åˆ°è¾¾ç›®æ ‡ç‚¹ï¼Œè¿›å…¥ä¸‹ä¸€ä¸ªè·¯å¾„ç‚¹
                        enemy.x = targetX;
                        enemy.y = targetY;
                        enemy.pathIndex++;
                    } else {
                        // å¦åˆ™æ­£å¸¸ç§»åŠ¨
                        enemy.x += (dx / dist) * enemy.currentSpeed * deltaTime;
                        enemy.y += (dy / dist) * enemy.currentSpeed * deltaTime;
                    }
                }
                
                // æ›´æ–°æ•Œäººæ•°é‡æ˜¾ç¤º
                enemiesDisplay.textContent = gameState.enemies.length;
            }
            
            // æ›´æ–°é˜²å¾¡å¡”çŠ¶æ€
            function updateTowers(timestamp, deltaTime) {
                for (const tower of gameState.towers) {
                    // å…µè¥ç”±ä¸“é—¨çš„å‡½æ•°å¤„ç†
                    if (tower.type === 'barracks') continue;
                    
                    // æŸ¥æ‰¾èŒƒå›´å†…çš„æ•Œäºº
                    let target = null;
                    let minDist = tower.range;
                    
                    for (const enemy of gameState.enemies) {
                        // è·³è¿‡è¢«æ§åˆ¶çš„æ•Œäºº
                        if (enemy.isControlled) continue;
                        
                        const dx = enemy.x - tower.x;
                        const dy = enemy.y - tower.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < minDist) {
                            minDist = dist;
                            target = enemy;
                        }
                    }
                    
                    // ç¦»å­ç‚®ç‰¹æ®Šå¤„ç†
                    if (tower.type === "ion") {
                        // å……èƒ½
                        tower.charge = Math.min(tower.maxCharge, tower.charge + deltaTime*0.5);
                        
                        if (target && tower.charge >= tower.maxCharge && timestamp - tower.lastShot > tower.cooldown) {
                            // å‘å°„ç¦»å­ç‚®
                            gameState.projectiles.push({
                                x: tower.x,
                                y: tower.y,
                                target: target,
                                damage: tower.damage,
                                splashRadius: tower.splashRadius,
                                splashDamage: tower.splashDamage,
                                color: "#9C27B0",
                                speed: 6,
                                effect: "ion"
                            });
                            
                            tower.charge = 0;
                            tower.lastShot = timestamp;
                        }
                    }
					
                    // å…‰æ£±å¡”ç‰¹æ®Šå¤„ç†
                    else if (tower.type === "prism") {
                        if (target && timestamp - tower.lastShot > tower.cooldown) {
                            // åˆ›å»ºå…‰æ£±å…‰æŸ
                            const bounceTargets = [target];
                            let currentTarget = target;
                            
                            // å¯»æ‰¾æŠ˜å°„ç›®æ ‡
                            for (let i = 1; i < tower.bounceCount; i++) {
                                let nextTarget = null;
                                let minBounceDist = tower.bounceRange;
                                
                                for (const enemy of gameState.enemies) {
                                    if (bounceTargets.includes(enemy)) continue;
                                    
                                    const dx = enemy.x - currentTarget.x;
                                    const dy = enemy.y - currentTarget.y;
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    
                                    if (dist < minBounceDist) {
                                        minBounceDist = dist;
                                        nextTarget = enemy;
                                    }
                                }
                                
                                if (nextTarget) {
                                    bounceTargets.push(nextTarget);
                                    currentTarget = nextTarget;
                                } else {
                                    break;
                                }
                            }
                            
                            // å¯¹æ‰€æœ‰æŠ˜å°„ç›®æ ‡é€ æˆä¼¤å®³
                            let damage = tower.damage;
                            for (const t of bounceTargets) {
                                t.health -= damage;
                                
                                // åˆ›å»ºå…‰æŸæ•ˆæœ
                                gameState.effects.push({
                                    type: 'prism',
                                    startX: tower.x,
                                    startY: tower.y,
                                    endX: t.x,
                                    endY: t.y,
                                    color: "#FF5252",
                                    duration: 300,
                                    startTime: timestamp
                                });
                                
                                // ä¼¤å®³è¡°å‡
                                damage *= (1 - tower.bounceDecay);
                            }
                            
                            tower.lastShot = timestamp;
                        }
                    }
					
					// æ¿€å…‰å¡”ç‰¹æ®Šå¤„ç†
                    else if (tower.type === "laser") {
                        if (target) {
                            // å¦‚æœç›®æ ‡å­˜åœ¨ï¼ŒæŒç»­æ”»å‡»
                            if (tower.target !== target) {
                                tower.target = target;
                                tower.attackTime = 0;
                            }
                            
                            // æ¯å¸§é€ æˆä¼¤å®³
                            target.health -= tower.damage * deltaTime / 60;
                            tower.attackTime += deltaTime;
                            
                            // åˆ›å»ºæ¿€å…‰æ•ˆæœ
                            gameState.effects.push({
                                type: 'laser',
                                startX: tower.x,
                                startY: tower.y,
                                endX: target.x,
                                endY: target.y,
                                color: "#FF5252",
                                duration: 100,
                                startTime: timestamp
                            });
                        } else {
                            tower.target = null;
                            tower.attackTime = 0;
                        }
                    } 
                    // æ ¸å¼¹å¡”ç‰¹æ®Šå¤„ç†
                    else if (tower.type === "nuke") {
                        if (timestamp - tower.lastShot > tower.cooldown) {
                            // å¯¹å…¨å±æ•Œäººé€ æˆä¼¤å®³
                            for (const enemy of gameState.enemies) {
                                enemy.health -= tower.damage;
                            }
                            
                            // åˆ›å»ºæ ¸çˆ†æ•ˆæœ
                            gameState.effects.push({
                                type: 'nuke',
                                x: canvas.width / 2,
                                y: canvas.height / 2,
                                radius: 500,
                                color: "#00E676",
                                duration: 2000,
                                startTime: timestamp
                            });
                            
                            tower.lastShot = timestamp;
                            showStatusMessage("èƒŒèƒŒèƒŒèƒŒèµ·äº†è¡Œå›Š!", "#00E676", 1500);
                        }
                    }
                    // è“„èƒ½å¡”ç‰¹æ®Šå¤„ç†
                    else if (tower.type === "energizer") {
                        if (target) {
                            if (tower.target !== target) {
                                tower.target = target;
                                tower.combo = 0;
                            }
                            
                            // æ”»å‡»æ•Œäºº
                            if (timestamp - tower.lastShot > tower.cooldown) {
                                // è®¡ç®—ä¼¤å®³ï¼ˆåŸºç¡€ä¼¤å®³ + è¿å‡»åŠ æˆï¼‰
                                const bonusDamage = tower.combo * (tower.maxDamage - tower.damage) / tower.maxCombo;
                                const totalDamage = tower.damage + bonusDamage;
                                
                                target.health -= totalDamage;
                                tower.lastShot = timestamp;
                                
                                // å¢åŠ è¿å‡»æ•°ï¼ˆæœ€å¤š10æ¬¡ï¼‰
                                if (tower.combo < tower.maxCombo) {
                                    tower.combo++;
                                }
                                
                                // åˆ›å»ºæ”»å‡»æ•ˆæœ
                                gameState.projectiles.push({
                                    x: tower.x,
                                    y: tower.y,
                                    target: target,
                                    damage: totalDamage,
                                    color: "#FF4081",
                                    speed: 5
                                });
                            }
                        } else {
                            tower.target = null;
                            tower.combo = 0;
                        }
                    }
					
                    // å°¤é‡Œå¡”ç‰¹æ®Šå¤„ç†
                    else if (tower.type === "yuri") {
                        if (target && timestamp - tower.lastShot > tower.cooldown) {
                            // æ§åˆ¶æ•Œäºº
                            target.isControlled = true;
                            target.controlledBy = tower;
                            target.controlEndTime = timestamp + tower.controlDuration;
                            
                            // æ·»åŠ åˆ°æ§åˆ¶åˆ—è¡¨
                            tower.controlledEnemies.push(target);
                            
                            // åˆ›å»ºæ§åˆ¶æ•ˆæœ
                            gameState.effects.push({
                                type: 'control',
                                x: target.x,
                                y: target.y,
                                radius: 20,
                                color: "#00BCD4",
                                duration: 1000,
                                startTime: timestamp
                            });
                            
                            tower.lastShot = timestamp;
                        }
                        
                        // æ¸…ç†æ§åˆ¶åˆ—è¡¨ä¸­çš„æ— æ•ˆæ•Œäºº
                        tower.controlledEnemies = tower.controlledEnemies.filter(e => 
                            e.isControlled && e.controlEndTime > timestamp
                        );
                    }
                    // å…¶ä»–é˜²å¾¡å¡”
                    else if (target && timestamp - tower.lastShot > tower.cooldown) {
                        // å¯’å†°å¡”
                        if (tower.type === "ice") {
                            // å¯’å†°å¡”åº”ç”¨å‡é€Ÿæ•ˆæœ
                            applyEffect(target, "slow", tower);
                            
                            // åˆ›å»ºå†°å¼¹æ•ˆæœ
                            gameState.projectiles.push({
                                x: tower.x,
                                y: tower.y,
                                target: target,
                                damage: tower.damage,
                                color: tower.color,
                                speed: 4,
                                effect: "ice"
                            });
                        } 
                        // ç«ç‚®å¡”
                        else if (tower.type === "cannon") {
                            // åˆ›å»ºç‚®å¼¹æ•ˆæœ
                            gameState.projectiles.push({
                                x: tower.x,
                                y: tower.y,
                                target: target,
                                damage: tower.damage,
                                splashRadius: tower.splashRadius,
                                splashDamage: tower.splashDamage,
                                color: tower.color,
                                speed: 3,
                                effect: "cannon"
                            });
                        }
                        // é›·ç”µå¡”
                        else if (tower.type === "lightning") {
                            // åˆ›å»ºé—ªç”µé“¾æ•ˆæœ
                            const chainTargets = [target];
                            let currentTarget = target;
                            
                            // å¯»æ‰¾è¿é”ç›®æ ‡
                            for (let i = 1; i < tower.chainCount; i++) {
                                let nextTarget = null;
                                let minChainDist = tower.chainRange;
                                
                                for (const enemy of gameState.enemies) {
                                    if (chainTargets.includes(enemy)) continue;
                                    
                                    const dx = enemy.x - currentTarget.x;
                                    const dy = enemy.y - currentTarget.y;
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    
                                    if (dist < minChainDist) {
                                        minChainDist = dist;
                                        nextTarget = enemy;
                                    }
                                }
                                
                                if (nextTarget) {
                                    chainTargets.push(nextTarget);
                                    currentTarget = nextTarget;
                                } else {
                                    break;
                                }
                            }
                            
                            // å¯¹æ‰€æœ‰è¿é”ç›®æ ‡é€ æˆä¼¤å®³
                            for (const t of chainTargets) {
                                t.health -= tower.damage;
                                
                                // åˆ›å»ºé—ªç”µæ•ˆæœ
                                gameState.effects.push({
                                    type: 'lightning',
                                    startX: tower.x,
                                    startY: tower.y,
                                    endX: t.x,
                                    endY: t.y,
                                    color: "#FFEB3B",
                                    duration: 200,
                                    startTime: timestamp
                                });
                            }
                        } 
                        // å¯¼å¼¹å¡”
                        else if (tower.type === "missile") {
                            // åˆ›å»ºå¯¼å¼¹
                            gameState.projectiles.push({
                                x: tower.x,
                                y: tower.y,
                                target: target,
                                damage: tower.damage,
                                splashRadius: tower.splashRadius,
                                splashDamage: tower.splashDamage,
                                color: "#FF9800",
                                speed: 3,
                                effect: "missile"
                            });
                        }
                        // æ¯’å¡”
                        else if (tower.type === "poison") {
                            // åº”ç”¨ä¸­æ¯’æ•ˆæœ
                            applyEffect(target, "poison", tower);
                            applyEffect(target, "slow", tower);
                            
                            // åˆ›å»ºæ¯’äº‘æ•ˆæœ
                            gameState.effects.push({
                                type: 'poison',
                                x: target.x,
                                y: target.y,
                                radius: 40,
                                color: "#66BB6A",
                                duration: 1000,
                                startTime: timestamp,
                                target: target
                            });
                        } 
                        // å…¶ä»–é˜²å¾¡å¡”
                        else {
                            gameState.projectiles.push({
                                x: tower.x,
                                y: tower.y,
                                target: target,
                                damage: tower.damage,
                                color: tower.color,
                                speed: 5
                            });
                        }
                        
                        tower.lastShot = timestamp;
                    }
                }
            }
            
            // æ›´æ–°å­å¼¹çŠ¶æ€
            function updateProjectiles(deltaTime) {
                for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                    const proj = gameState.projectiles[i];
                    
                    // ç§»åŠ¨åˆ°ç›®æ ‡
                    const dx = proj.target.x - proj.x;
                    const dy = proj.target.y - proj.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < proj.speed * deltaTime) {
                        // å‡»ä¸­ç›®æ ‡
                        proj.target.health -= proj.damage;
                        
                        // åˆ›å»ºå‡»ä¸­æ•ˆæœ
                        if (proj.effect === "ice") {
                            gameState.effects.push({
                                x: proj.target.x,
                                y: proj.target.y,
                                radius: 30,
                                color: "#29B6F6",
                                duration: 500,
                                startTime: Date.now()
                            });
                        } 
                        // ç«ç‚®çˆ†ç‚¸æ•ˆæœ
                        else if (proj.effect === "cannon") {
                            // å¯¹çˆ†ç‚¸èŒƒå›´å†…çš„æ•Œäººé€ æˆä¼¤å®³
                            for (const enemy of gameState.enemies) {
                                const dx = enemy.x - proj.target.x;
                                const dy = enemy.y - proj.target.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                
                                if (dist < proj.splashRadius) {
                                    // ä¼¤å®³éšè·ç¦»è¡°å‡
                                    const damageMultiplier = 1 - (dist / proj.splashRadius);
                                    enemy.health -= proj.splashDamage * damageMultiplier;
                                }
                            }
                            
                            // åˆ›å»ºçˆ†ç‚¸æ•ˆæœ
                            gameState.effects.push({
                                type: 'explosion',
                                x: proj.target.x,
                                y: proj.target.y,
                                radius: proj.splashRadius,
                                color: "#FF5722",
                                duration: 1000,
                                startTime: Date.now()
                            });
                        }
                        // å¯¼å¼¹çˆ†ç‚¸æ•ˆæœ
                        else if (proj.effect === "missile") {
                            // å¯¹çˆ†ç‚¸èŒƒå›´å†…çš„æ•Œäººé€ æˆä¼¤å®³
                            for (const enemy of gameState.enemies) {
                                const dx = enemy.x - proj.target.x;
                                const dy = enemy.y - proj.target.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                
                                if (dist < proj.splashRadius) {
                                    // ä¼¤å®³éšè·ç¦»è¡°å‡
                                    const damageMultiplier = 1 - (dist / proj.splashRadius);
                                    enemy.health -= proj.splashDamage * damageMultiplier;
                                }
                            }
                            
                            // åˆ›å»ºçˆ†ç‚¸æ•ˆæœ
                            gameState.effects.push({
                                type: 'explosion',
                                x: proj.target.x,
                                y: proj.target.y,
                                radius: proj.splashRadius,
                                color: "#FF5722",
                                duration: 1000,
                                startTime: Date.now()
                            });
                        }
                        // ç¦»å­ç‚®çˆ†ç‚¸æ•ˆæœ
                        else if (proj.effect === "ion") {
                            // å¯¹çˆ†ç‚¸èŒƒå›´å†…çš„æ•Œäººé€ æˆä¼¤å®³
                            for (const enemy of gameState.enemies) {
                                const dx = enemy.x - proj.target.x;
                                const dy = enemy.y - proj.target.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                
                                if (dist < proj.splashRadius) {
                                    // ä¼¤å®³éšè·ç¦»è¡°å‡
                                    const damageMultiplier = 1;
                                    enemy.health -= proj.splashDamage * damageMultiplier;
                                }
                            }
                            
                            // åˆ›å»ºçˆ†ç‚¸æ•ˆæœ
                            gameState.effects.push({
                                type: 'ion-explosion',
                                x: proj.target.x,
                                y: proj.target.y,
                                radius: proj.splashRadius,
                                color: "#9C27B0",
                                duration: 1000,
                                startTime: Date.now()
                            });
                        }
                        
                        gameState.projectiles.splice(i, 1);
                    } else {
                        proj.x += (dx / dist) * proj.speed * deltaTime;
                        proj.y += (dy / dist) * proj.speed * deltaTime;
                    }
                }
            }
            
            // æ›´æ–°æ•ˆæœçŠ¶æ€
            function updateEffects(timestamp) {
                for (let i = gameState.effects.length - 1; i >= 0; i--) {
                    const effect = gameState.effects[i];
                    
                    // è·Ÿéšç›®æ ‡ï¼ˆå¦‚æœæ˜¯ç›®æ ‡æ•ˆæœï¼‰
                    if (effect.target) {
                        effect.x = effect.target.x;
                        effect.y = effect.target.y;
                    }
                    
                    // æ£€æŸ¥æ•ˆæœæ˜¯å¦ç»“æŸ
                    if (timestamp - effect.startTime > effect.duration) {
                        gameState.effects.splice(i, 1);
                    }
                }
            }
            
            // ç»˜åˆ¶æ¸¸æˆåœ°å›¾
            function drawMap() {
                const level = levels[gameState.currentLevel];
                
                // ç»˜åˆ¶èƒŒæ™¯
                if (gameState.currentLevel === 1) {
                    ctx.fillStyle = '#0c2461';
                } else if (gameState.currentLevel === 2) {
                    ctx.fillStyle = '#795548';
                } else if (gameState.currentLevel === 3) {
                    ctx.fillStyle = '#90A4AE';
                } else {
                    ctx.fillStyle = '#4527A0';
                }
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // ç»˜åˆ¶è‰åœ°
                if (gameState.currentLevel === 1) {
                    ctx.fillStyle = '#2e7d32';
                } else if (gameState.currentLevel === 2) {
                    ctx.fillStyle = '#8D6E63';
                } else if (gameState.currentLevel === 3) {
                    ctx.fillStyle = '#B0BEC5';
                } else {
                    ctx.fillStyle = '#5C6BC0';
                }
                ctx.beginPath();
                ctx.rect(0, 0, canvas.width, canvas.height);
                ctx.fill();
                
                // ç»˜åˆ¶è·¯å¾„
                ctx.strokeStyle = '#795548';
                ctx.lineWidth = 50;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                
                for (let i = 0; i < gameState.path.length; i++) {
                    if (i === 0) {
                        ctx.moveTo(gameState.path[i].x, gameState.path[i].y);
                    } else {
                        ctx.lineTo(gameState.path[i].x, gameState.path[i].y);
                    }
                }
                
                ctx.stroke();
                
                // ç»˜åˆ¶åŸå ¡
                ctx.fillStyle = '#8D6E63';
                ctx.fillRect(750, 100, 50, 100);
                ctx.fillStyle = '#5D4037';
                ctx.fillRect(765, 70, 20, 30);
                
                // ç»˜åˆ¶å¯æ”¾ç½®åŒºåŸŸæç¤º
                ctx.fillStyle = 'rgba(76, 175, 80, 0.2)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // ç»˜åˆ¶è·¯å¾„ä¸Šçš„ä¸å¯æ”¾ç½®åŒºåŸŸ
                ctx.strokeStyle = 'rgba(255, 87, 34, 0.3)';
                ctx.lineWidth = 60;
                ctx.beginPath();
                
                for (let i = 0; i < gameState.path.length; i++) {
                    if (i === 0) {
                        ctx.moveTo(gameState.path[i].x, gameState.path[i].y);
                    } else {
                        ctx.lineTo(gameState.path[i].x, gameState.path[i].y);
                    }
                }
                
                ctx.stroke();
                
                // ç»˜åˆ¶å…³å¡åç§°
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(level.name, canvas.width / 2, 30);
                
                // ç»˜åˆ¶éš¾åº¦
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 16px Arial';
                ctx.fillText(`éš¾åº¦: ${gameState.difficulty}`, canvas.width - 80, 30);
            }
            
            // ç»˜åˆ¶æ•Œäºº
            function drawEnemies() {
                for (const enemy of gameState.enemies) {
                    // ç»˜åˆ¶æ•Œäºº
                    ctx.fillStyle = enemy.color;
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ç»˜åˆ¶æ•Œäººç±»å‹å›¾æ ‡
                    ctx.fillStyle = '#000';
                    ctx.font = enemy.size + 'px Arial';
                    ctx.textAlign = 'center';
                    
                    let icon = "ğŸ‘¾";
                    if (enemy.type === "orc") icon = "ğŸ‘¹";
                    else if (enemy.type === "ogre") icon = "ğŸ‘»";
                    else if (enemy.type === "knight") icon = "ğŸ¤´";
                    else if (enemy.type === "flying") icon = "ğŸ¦‡";
                    else if (enemy.type === "boss") icon = "ğŸ‘‘";
                    
                    ctx.fillText(icon, enemy.x, enemy.y + enemy.size/3);
                    
                    // ç»˜åˆ¶ç”Ÿå‘½æ¡
                    const healthPercent = enemy.health / enemy.maxHealth;
                    ctx.fillStyle = '#555';
                    ctx.fillRect(enemy.x - 25, enemy.y - enemy.size - 15, 50, 8);
                    ctx.fillStyle = healthPercent > 0.5 ? '#4CAF50' : '#F44336';
                    ctx.fillRect(enemy.x - 25, enemy.y - enemy.size - 15, 50 * healthPercent, 8);
                    
                    // ç»˜åˆ¶æ•ˆæœå›¾æ ‡
                    let effectY = enemy.y - enemy.size - 30;
                    for (const effect of enemy.effects) {
                        if (effect.type === "slow") {
                            ctx.fillStyle = '#29B6F6';
                            ctx.fillText('â„ï¸', enemy.x, effectY);
                            effectY -= 20;
                        } else if (effect.type === "poison") {
                            ctx.fillStyle = '#66BB6A';
                            ctx.fillText('â˜ ï¸', enemy.x, effectY);
                            effectY -= 20;
                        }
                    }
                    
                    // è¢«æ§åˆ¶çš„æ•Œäºº
                    if (enemy.isControlled) {
                        ctx.fillStyle = '#00BCD4';
                        ctx.fillText('ğŸ§ ', enemy.x, effectY);
                    }
                }
            }
            
            // ç»˜åˆ¶é˜²å¾¡å¡”
            function drawTowers() {
                for (const tower of gameState.towers) {
                    // ç»˜åˆ¶é˜²å¾¡å¡”åº•åº§
                    ctx.fillStyle = '#777';
                    ctx.beginPath();
                    ctx.arc(tower.x, tower.y, 20, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ç»˜åˆ¶é˜²å¾¡å¡”ä¸»ä½“
                    ctx.fillStyle = tower.color;
                    ctx.beginPath();
                    ctx.arc(tower.x, tower.y, 15, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ç»˜åˆ¶é˜²å¾¡å¡”ç±»å‹å›¾æ ‡
                    let icon = "ğŸ¹";
                    if (tower.type === "cannon") icon = "ğŸ’£";
                    else if (tower.type === "mage") icon = "ğŸ”®";
                    else if (tower.type === "barracks") icon = "ğŸ›¡ï¸";
                    else if (tower.type === "ice") icon = "â„ï¸";
                    else if (tower.type === "lightning") icon = "âš¡";
                    else if (tower.type === "missile") icon = "ğŸš€";
                    else if (tower.type === "poison") icon = "â˜ ï¸";
                    else if (tower.type === "ion") icon = "ğŸ”‹";
                    else if (tower.type === "prism") icon = "âœ¨";
                    else if (tower.type === "yuri") icon = "ğŸ§ ";
                    
                    ctx.fillStyle = '#000';
                    ctx.font = '20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(icon, tower.x, tower.y + 5);
                    
                    // ç»˜åˆ¶ç­‰çº§
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 12px Arial';
                    ctx.fillText(`Lv.${tower.level}`, tower.x, tower.y - 25);
                    
                    // ç¦»å­ç‚®ç»˜åˆ¶å……èƒ½æ¡
                    if (tower.type === "ion") {
                        const chargePercent = tower.charge / tower.maxCharge;
                        ctx.fillStyle = '#555';
                        ctx.fillRect(tower.x - 25, tower.y - 45, 50, 8);
                        ctx.fillStyle = chargePercent < 1 ? '#9C27B0' : '#FFD700';
                        ctx.fillRect(tower.x - 25, tower.y - 45, 50 * chargePercent, 8);
                    }
                    
                    // å°¤é‡Œå¡”ç»˜åˆ¶æ§åˆ¶æ•°é‡
                    if (tower.type === "yuri") {
                        ctx.fillStyle = '#00BCD4';
                        ctx.font = 'bold 12px Arial';
                        ctx.fillText(`æ§åˆ¶: ${tower.controlledEnemies.length}`, tower.x, tower.y - 60);
                    }
                    
                    // å¦‚æœé€‰ä¸­ï¼Œç»˜åˆ¶æ”»å‡»èŒƒå›´
                    if (gameState.selectedTower === tower) {
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(tower.x, tower.y, tower.range, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }
            }
            
            // ç»˜åˆ¶å£«å…µ
            function drawSoldiers() {
                for (const tower of gameState.towers) {
                    if (tower.type !== 'barracks') continue;
                    
                    for (const soldier of tower.soldiers) {
                        // ç»˜åˆ¶å£«å…µ
                        ctx.fillStyle = soldier.color;
                        ctx.beginPath();
                        ctx.arc(soldier.x, soldier.y, 10, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // ç»˜åˆ¶å£«å…µå›¾æ ‡
                        ctx.fillStyle = '#000';
                        ctx.font = '15px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('ğŸ’‚', soldier.x, soldier.y + 3);
                        
                        // ç»˜åˆ¶æ”»å‡»èŒƒå›´ï¼ˆå½“æœ‰ç›®æ ‡æ—¶ï¼‰
                        if (soldier.target) {
                            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.arc(soldier.x, soldier.y, soldier.range, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                    }
                }
            }
            
            // ç»˜åˆ¶å­å¼¹
            function drawProjectiles() {
                for (const proj of gameState.projectiles) {
                    // å¯¼å¼¹ç»˜åˆ¶
                    if (proj.effect === "missile") {
                        ctx.fillStyle = proj.color;
                        ctx.beginPath();
                        ctx.arc(proj.x, proj.y, 6, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // å¯¼å¼¹å°¾ç„°
                        ctx.strokeStyle = "#FF5722";
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(proj.x, proj.y);
                        
                        // è®¡ç®—å¯¼å¼¹æ–¹å‘
                        const dx = proj.target.x - proj.x;
                        const dy = proj.target.y - proj.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist > 0) {
                            ctx.lineTo(
                                proj.x - (dx / dist) * 15,
                                proj.y - (dy / dist) * 15
                            );
                        }
                        ctx.stroke();
                    } 
                    // å…¶ä»–å­å¼¹
                    else {
                        ctx.strokeStyle = proj.color;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(proj.x, proj.y);
                        ctx.lineTo(proj.target.x, proj.target.y);
                        ctx.stroke();
                        
                        // ç»˜åˆ¶å­å¼¹å¤´
                        ctx.fillStyle = proj.color;
                        ctx.beginPath();
                        ctx.arc(proj.x, proj.y, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            // ç»˜åˆ¶æ•ˆæœ
            function drawEffects() {
                const now = Date.now();
                
                for (const effect of gameState.effects) {
                    const elapsed = now - effect.startTime;
                    const progress = Math.min(1, elapsed / effect.duration); // ç¡®ä¿progressä¸è¶…è¿‡1
                    
                    // ç»˜åˆ¶æ¯’äº‘æ•ˆæœ
                    if (effect.type === 'poison') {
                        ctx.globalAlpha = 1 - progress * 0.8;
                        ctx.fillStyle = "#66BB6A";
                        ctx.beginPath();
                        ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    // ç»˜åˆ¶å†°å¼¹æ•ˆæœ
                    else if (effect.type === 'ice') {
                        ctx.globalAlpha = 1 - progress;
                        ctx.strokeStyle = "#29B6F6";
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    // ç»˜åˆ¶é—ªç”µæ•ˆæœ
                    else if (effect.type === 'lightning') {
                        ctx.globalAlpha = 1;
                        ctx.strokeStyle = effect.color;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(effect.startX, effect.startY);
                        
                        // åˆ›å»ºé”¯é½¿çŠ¶é—ªç”µæ•ˆæœ
                        const dx = effect.endX - effect.startX;
                        const dy = effect.endY - effect.startY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const segments = 8;
                        
                        for (let i = 0; i <= segments; i++) {
                            const t = i / segments;
                            const offsetX = (Math.random() - 0.5) * 10;
                            const offsetY = (Math.random() - 0.5) * 10;
                            const x = effect.startX + dx * t + offsetX;
                            const y = effect.startY + dy * t + offsetY;
                            
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        
                        ctx.stroke();
                    }
                    // ç»˜åˆ¶çˆ†ç‚¸æ•ˆæœ
                    else if (effect.type === 'explosion') {
                        // çˆ†ç‚¸é—ªå…‰æ•ˆæœ
                        ctx.globalAlpha = 1 - progress;
                        ctx.fillStyle = effect.color;
                        ctx.beginPath();
                        ctx.arc(effect.x, effect.y, effect.radius * progress, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // çˆ†ç‚¸å†²å‡»æ³¢
                        ctx.globalAlpha = (1 - progress) * 0.5;
                        ctx.strokeStyle = "#FFEB3B";
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(effect.x, effect.y, effect.radius * progress * 1.2, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // çˆ†ç‚¸ç¢ç‰‡
                        if (progress < 0.3) {
                            ctx.globalAlpha = 1 - progress * 3;
                            ctx.fillStyle = "#FF9800";
                            for (let i = 0; i < 8; i++) {
                                const angle = Math.PI * 2 * i / 8;
                                const distance = effect.radius * progress * 1.5;
                                const x = effect.x + Math.cos(angle) * distance;
                                const y = effect.y + Math.sin(angle) * distance;
                                
                                ctx.beginPath();
                                ctx.arc(
                                    x, y,
                                    3 + Math.random() * 4,
                                    0,
                                    Math.PI * 2
                                );
                                ctx.fill();
                            }
                        }
                    }
					
					// ç»˜åˆ¶æ¿€å…‰æ•ˆæœ
                    else if (effect.type === 'laser') {
                        ctx.strokeStyle = "#FF5252";
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(effect.startX, effect.startY);
                        ctx.lineTo(effect.endX, effect.endY);
                        ctx.stroke();
                        
                        // ç»˜åˆ¶æ¿€å…‰å…‰æ™•
                        ctx.globalAlpha = 0.3;
                        ctx.lineWidth = 12;
                        ctx.stroke();
                        ctx.globalAlpha = 1.0;
                    }
                    // ç»˜åˆ¶æ ¸çˆ†æ•ˆæœ
                    else if (effect.type === 'nuke') {
                        ctx.globalAlpha = 1 - progress * 0.8;
                        
                        // ç»˜åˆ¶å†²å‡»æ³¢
                        ctx.strokeStyle = "#00E676";
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(effect.x, effect.y, effect.radius * progress, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // ç»˜åˆ¶è˜‘è‡äº‘
                        ctx.fillStyle = "#00E676";
                        ctx.beginPath();
                        ctx.arc(effect.x, effect.y - effect.radius * progress * 0.3, effect.radius * progress * 0.4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.beginPath();
                        ctx.arc(effect.x, effect.y - effect.radius * progress * 0.6, effect.radius * progress * 0.3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.globalAlpha = 1.0;
                    }
					
                    // ç»˜åˆ¶è¿‘æˆ˜æ”»å‡»æ•ˆæœ
                    else if (effect.type === 'melee') {
                        ctx.globalAlpha = 1 - progress;
                        ctx.fillStyle = effect.color;
                        ctx.beginPath();
                        ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    // ç»˜åˆ¶å‡çº§ç‰¹æ•ˆ
                    else if (effect.type === 'upgrade') {
                        ctx.globalAlpha = 1 - progress;
                        
                        // ç»˜åˆ¶ä¸­å¿ƒå…‰ç¯
                        ctx.fillStyle = effect.color;
                        ctx.beginPath();
                        ctx.arc(effect.x, effect.y, effect.radius * (1 + progress), 0, Math.PI * 2);
                        ctx.fill();
                        
                        // ç»˜åˆ¶ç²’å­
                        for (const particle of effect.particles) {
                            const angle = particle.angle;
                            const distance = particle.distance + particle.speed * elapsed / 20;
                            
                            ctx.fillStyle = particle.color;
                            ctx.beginPath();
                            ctx.arc(
                                effect.x + Math.cos(angle) * distance,
                                effect.y + Math.sin(angle) * distance,
                                particle.size,
                                0,
                                Math.PI * 2
                            );
                            ctx.fill();
                        }
                    }
                    // ç»˜åˆ¶æ­»äº¡ç‰¹æ•ˆ
                    else if (effect.type === 'death') {
                        ctx.globalAlpha = 1 - progress;
                        
                        // ç»˜åˆ¶çˆ†ç‚¸ç¯
                        ctx.strokeStyle = effect.color;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(effect.x, effect.y, effect.radius * (1 + progress * 2), 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // ç»˜åˆ¶å†…éƒ¨çˆ†ç‚¸
                        ctx.fillStyle = effect.color;
                        ctx.beginPath();
                        ctx.arc(effect.x, effect.y, effect.radius * progress, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // ç»˜åˆ¶ç²’å­
                        ctx.fillStyle = "#FFD700";
                        for (let i = 0; i < 10; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = effect.radius * progress * 2;
                            ctx.beginPath();
                            ctx.arc(
                                effect.x + Math.cos(angle) * distance,
                                effect.y + Math.sin(angle) * distance,
                                2,
                                0,
                                Math.PI * 2
                            );
                            ctx.fill();
                        }
                    }
                    // ç»˜åˆ¶å…‰æ£±æ•ˆæœ
                    else if (effect.type === 'prism') {
                        ctx.strokeStyle = effect.color;
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(effect.startX, effect.startY);
                        ctx.lineTo(effect.endX, effect.endY);
                        ctx.stroke();
                        
                        // ç»˜åˆ¶å…‰æ™•
                        ctx.globalAlpha = 0.3;
                        ctx.lineWidth = 12;
                        ctx.stroke();
                        ctx.globalAlpha = 1.0;
                    }
                    // ç»˜åˆ¶æ§åˆ¶æ•ˆæœ
                    else if (effect.type === 'control') {
                        ctx.globalAlpha = 1 - progress;
                        ctx.strokeStyle = effect.color;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(effect.x, effect.y, effect.radius * (1 + progress), 0, Math.PI * 2);
                        ctx.stroke();
                        
                        ctx.fillStyle = effect.color;
                        ctx.font = '20px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('ğŸ§ ', effect.x, effect.y + 5);
                    }
                    // ç»˜åˆ¶ç¦»å­ç‚®çˆ†ç‚¸æ•ˆæœ
                    else if (effect.type === 'ion-explosion') {
                        // çˆ†ç‚¸é—ªå…‰æ•ˆæœ
                        ctx.globalAlpha = 1 - progress;
                        ctx.fillStyle = effect.color;
                        ctx.beginPath();
                        ctx.arc(effect.x, effect.y, effect.radius * progress, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // ç»˜åˆ¶ç¦»å­æ•ˆæœ
                        for (let i = 0; i < 10; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = effect.radius * progress * 1.5;
                            ctx.beginPath();
                            ctx.arc(
                                effect.x + Math.cos(angle) * distance,
                                effect.y + Math.sin(angle) * distance,
                                3,
                                0,
                                Math.PI * 2
                            );
                            ctx.fill();
                        }
                    }
                }
                
                ctx.globalAlpha = 1.0;
            }
            
            // ç»˜åˆ¶æ¸¸æˆçŠ¶æ€
            function drawUI() {
                // ç»˜åˆ¶é‡‘å¸å›¾æ ‡
                ctx.fillStyle = '#FFD700';
                ctx.font = '20px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('ğŸ’°', 10, 30);
                ctx.fillText(gameState.gold.toString(), 40, 30);
                
                // ç»˜åˆ¶ç”Ÿå‘½å€¼
                ctx.fillStyle = '#F44336';
                ctx.fillText('â¤ï¸', 10, 60);
                ctx.fillText(gameState.lives.toString(), 40, 60);
                
                // ç»˜åˆ¶æ³¢æ•°
                ctx.fillStyle = '#2196F3';
                ctx.fillText('âš”ï¸', 10, 90);
                ctx.fillText(`${gameState.wave}/${gameState.maxWave}`, 40, 90);
                
                // ç»˜åˆ¶å…³å¡
                ctx.fillStyle = '#9C27B0';
                ctx.fillText('ğŸ†', 10, 120);
                ctx.fillText(`${gameState.currentLevel}/4`, 40, 120);
                
                // æ¸¸æˆç»“æŸä¿¡æ¯
                if (gameState.gameOver) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = '#F44336';
                    ctx.font = 'bold 48px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('æ¸¸æˆç»“æŸ', canvas.width / 2, canvas.height / 2 - 30);
                    
                    ctx.fillStyle = '#FFF';
                    ctx.font = '24px Arial';
                    ctx.fillText('ä½ çš„åŸå ¡è¢«æ•Œäººæ”»é™·äº†', canvas.width / 2, canvas.height / 2 + 30);
                    
                    ctx.fillText('ç‚¹å‡»å±å¹•é‡æ–°å¼€å§‹', canvas.width / 2, canvas.height / 2 + 80);
                    
                    // æ·»åŠ å¤±è´¥åŠ¨ç”»
                    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2, canvas.height / 2, 100 + Math.sin(Date.now()/200)*20, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // æ¸¸æˆèƒœåˆ©ä¿¡æ¯
                if (gameState.gameWon) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = '#4CAF50';
                    ctx.font = 'bold 48px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('ç‹å›½èƒœåˆ©ï¼', canvas.width / 2, canvas.height / 2 - 30);
                    
                    ctx.fillStyle = '#FFF';
                    ctx.font = '24px Arial';
                    ctx.fillText('ä½ æˆåŠŸä¿å«äº†ç‹å›½ï¼', canvas.width / 2, canvas.height / 2 + 30);
                    
                    ctx.fillText('ç‚¹å‡»å±å¹•é‡æ–°å¼€å§‹', canvas.width / 2, canvas.height / 2 + 80);
                    
                    // æ·»åŠ èƒœåˆ©åŠ¨ç”»
                    ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2, canvas.height / 2, 100 + Math.sin(Date.now()/200)*20, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // æ·»åŠ çƒŸèŠ±ç²’å­
                    ctx.fillStyle = "#FFD700";
                    for (let i = 0; i < 20; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = 150 + Math.random() * 50;
                        const x = canvas.width / 2 + Math.cos(angle) * distance;
                        const y = canvas.height / 2 + Math.sin(angle) * distance;
                        
                        ctx.beginPath();
                        ctx.arc(x, y, 2 + Math.random() * 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // å…³å¡å®Œæˆä¿¡æ¯
                if (gameState.levelComplete) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 48px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('å…³å¡å®Œæˆ!', canvas.width / 2, canvas.height / 2 - 50);
                    
                    ctx.fillStyle = '#FFF';
                    ctx.font = '24æ Arial';
                    ctx.fillText(`æ­å–œé€šè¿‡ç¬¬${gameState.currentLevel}å…³`, canvas.width / 2, canvas.height / 2);
                    
                    if (gameState.currentLevel < gameState.maxLevel) {
                        ctx.fillText('ç‚¹å‡»"ä¸‹ä¸€å…³"ç»§ç»­æŒ‘æˆ˜', canvas.width / 2, canvas.height / 2 + 50);
                    } else {
                        ctx.fillText('ä½ å·²å®Œæˆæ‰€æœ‰å…³å¡ï¼', canvas.width / 2, canvas.height / 2 + 50);
                    }
                    
                    // æ·»åŠ åº†ç¥åŠ¨ç”»
                    ctx.strokeStyle = 'rgba(255, 215, 0, 0.5)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2, canvas.height / 2, 100 + Math.sin(Date.now()/200)*20, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            
            // æ›´æ–°æ¸¸æˆçŠ¶æ€æ˜¾ç¤º
            function updateStats() {
                goldDisplay.textContent = gameState.gold;
                livesDisplay.textContent = gameState.lives;
                waveDisplay.textContent = gameState.wave-1;
                maxWaveDisplay.textContent = gameState.maxWave;
                levelDisplay.textContent = gameState.currentLevel;
                
                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                nextWaveBtn.disabled = !gameState.gameRunning || gameState.enemies.length > 0 || gameState.isWaveActive;
                
                // æ›´æ–°å‡çº§æŒ‰é’®çŠ¶æ€
                if (gameState.selectedTower) {
                    upgradeBtn.disabled = gameState.gold < 100 || 
                                         gameState.selectedTower.level >= gameState.selectedTower.maxLevel;
                } else {
                    upgradeBtn.disabled = true;
                }
            }
            
            // å¼€å§‹ä¸‹ä¸€æ³¢æ•Œäºº
            function startNextWave() {
                // ä¿®å¤ï¼šåªåœ¨æ¸¸æˆè¿è¡Œæ—¶æ‰è§¦å‘ä¸‹ä¸€æ³¢
                if (!gameState.gameRunning) return;
                if (gameState.gameOver || gameState.gameWon || gameState.levelComplete) return;
                
                if (gameState.wave > gameState.maxWave) return;
                
                const level = levels[gameState.currentLevel];
                const waveConfig = level.enemyConfig[gameState.wave - 1];
                
                if (!waveConfig) return;
                
                // æ ‡è®°æ³¢æ¬¡å¼€å§‹
                gameState.isWaveActive = true;
                
                // ç”Ÿæˆæ•Œäºº
                for (let i = 0; i < waveConfig.count; i++) {
                    setTimeout(() => {
                        createEnemy(waveConfig.type);
                        // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰æ•Œäººéƒ½å·²ç”Ÿæˆ
                        if (i === waveConfig.count - 1) {
                            gameState.isWaveActive = false;
                        }
                    }, i * waveConfig.delay);
                }
                
                gameState.wave++;
                
                // æ£€æŸ¥æ˜¯å¦å®Œæˆæ‰€æœ‰æ³¢æ¬¡
                if (gameState.wave > gameState.maxWave+1) {
                    setTimeout(() => {
                        // å®Œæˆå½“å‰å…³å¡
                        gameState.levelComplete = true;
                        gameState.gameRunning = false;
                        startBtn.textContent = gameState.currentLevel < gameState.maxLevel ? "ä¸‹ä¸€å…³" : "é‡æ–°å¼€å§‹";
                        showStatusMessage("å…³å¡å®Œæˆ!", "#4CAF50", 3000);
                    }, 3000);
                }
                
                updateStats();
            }
            
            // å¼€å§‹æ–°å…³å¡
            function startNewLevel() {
                gameState.levelComplete = false;
                gameState.wave = 1;
                gameState.enemies = [];
                gameState.towers = [];
                gameState.soldiers = [];
                gameState.projectiles = [];
                gameState.effects = [];
                gameState.selectedTowerType = null;
                gameState.selectedTower = null;
                gameState.isWaveActive = false;
                
                // æ ¹æ®éš¾åº¦è°ƒæ•´åˆå§‹é‡‘å¸å’Œç”Ÿå‘½å€¼
                const difficultyFactor = 1 - (gameState.difficulty - 1) * 0.1;
                gameState.gold = Math.floor(300 * difficultyFactor);
                gameState.lives = Math.floor(5 * difficultyFactor);
                
                // å–æ¶ˆæ‰€æœ‰é€‰ä¸­çš„é˜²å¾¡å¡”
                towerOption.forEach(option => option.classList.remove('selected'));
                
                initPath();
                updateStats();
                
                startBtn.textContent = 'å¼€å§‹æ¸¸æˆ';
                nextWaveBtn.disabled = true;
                upgradeBtn.disabled = true;
            }
            
            // æ¸¸æˆä¸»å¾ªç¯
            function gameLoop(timestamp) {
                // è®¡ç®—æ—¶é—´å¢é‡
                const deltaTime = Math.min(50, timestamp - gameState.lastTime) / 16.67;
                gameState.lastTime = timestamp;
                
                // æ¸…é™¤ç”»å¸ƒ
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // ç»˜åˆ¶æ¸¸æˆå…ƒç´ 
                drawMap();
                drawEffects();
                drawEnemies();
                drawTowers();
                drawSoldiers();
                drawProjectiles();
                drawUI();
                
                // æ›´æ–°æ¸¸æˆçŠ¶æ€
                if (gameState.gameRunning && !gameState.gameOver && !gameState.gameWon && !gameState.levelComplete) {
                    updateEnemyEffects(timestamp);
                    updateEnemies(deltaTime, timestamp);
                    
                    // å¦‚æœæ¸¸æˆç»“æŸåˆ™ä¸å†æ›´æ–°å…¶ä»–çŠ¶æ€
                    if (gameState.gameOver) return;
                    
                    updateTowers(timestamp, deltaTime);
                    updateSoldiers(timestamp);
                    updateProjectiles(deltaTime);
                    updateEffects(timestamp);
                    updateStats();
                    
                    // æ£€æŸ¥æ¸¸æˆå¤±è´¥æ¡ä»¶
                    if (gameState.lives <= 0) {
                        gameState.gameOver = true;
                        gameState.gameRunning = false;
                        showStatusMessage("æ¸¸æˆç»“æŸ! åŸå ¡è¢«æ”»é™·", "#F44336", 3000);
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦å®Œæˆæ‰€æœ‰æ³¢æ¬¡
                    if (gameState.wave > gameState.maxWave+1 && gameState.enemies.length === 0 && !gameState.isWaveActive) {
                        gameState.levelComplete = true;
                        gameState.gameRunning = false;
                        startBtn.textContent = gameState.currentLevel < gameState.maxLevel ? "ä¸‹ä¸€å…³" : "é‡æ–°å¼€å§‹";
                        showStatusMessage("å…³å¡å®Œæˆ!", "#4CAF50", 3000);
                    }
                }
                
                requestAnimationFrame(gameLoop);
            }
            
            // åˆå§‹åŒ–æ¸¸æˆ
            function initGame() {
                gameState.gold = 300;
                gameState.lives = 5;
                gameState.wave = 1;
                gameState.enemies = [];
                gameState.towers = [];
                gameState.soldiers = [];
                gameState.projectiles = [];
                gameState.effects = [];
                gameState.selectedTowerType = null;
                gameState.selectedTower = null;
                gameState.gameRunning = false;
                gameState.gameOver = false;
                gameState.gameWon = false;
                gameState.levelComplete = false;
                gameState.lastTime = 0;
                gameState.currentLevel = 1;
                gameState.difficulty = 1;
                gameState.isWaveActive = false;
                
                initPath();
                updateStats();
                
                // å–æ¶ˆæ‰€æœ‰é€‰ä¸­çš„é˜²å¾¡å¡”
                towerOption.forEach(option => option.classList.remove('selected'));
                levelOption.forEach((opt, i) => {
                    opt.classList.toggle('selected', i === 0);
                });
                
                startBtn.textContent = 'å¼€å§‹æ¸¸æˆ';
                nextWaveBtn.disabled = true;
                upgradeBtn.disabled = true;
            }
            
            // äº‹ä»¶ç›‘å¬
            startBtn.addEventListener('click', () => {
                if (gameState.levelComplete) {
                    if (gameState.currentLevel < gameState.maxLevel) {
                        gameState.currentLevel++;
                        startNewLevel();
                    } else {
                        gameState.gameWon = true;
                        gameState.levelComplete = false;
                    }
                    return;
                }
                
                if (!gameState.gameRunning && !gameState.gameOver && !gameState.gameWon) {
                    gameState.gameRunning = true;
                    startBtn.textContent = 'æš‚åœæ¸¸æˆ';
                    startNextWave();
                } else if (gameState.gameRunning) {
                    gameState.gameRunning = false;
                    startBtn.textContent = 'ç»§ç»­æ¸¸æˆ';
                } else if (gameState.gameOver || gameState.gameWon) {
                    initGame();
                }
            });
            
            nextWaveBtn.addEventListener('click', startNextWave);
            
            upgradeBtn.addEventListener('click', upgradeTower);
            
            towerOption.forEach(option => {
                option.addEventListener('click', () => {
                    // å–æ¶ˆæ‰€æœ‰é€‰ä¸­çš„é˜²å¾¡å¡”
                    towerOption.forEach(opt => opt.classList.remove('selected'));
                    
                    // é€‰ä¸­å½“å‰é˜²å¾¡å¡”
                    option.classList.add('selected');
                    
                    const type = option.dataset.type;
                    const cost = parseInt(option.dataset.cost);
                    
                    if (gameState.gold >= cost) {
                        gameState.selectedTowerType = type;
                    } else {
                        gameState.selectedTowerType = null;
                        option.classList.remove('selected');
                        showStatusMessage("é‡‘å¸ä¸è¶³!", "#F44336");
                    }
                });
            });
            
            levelOption.forEach(option => {
                option.addEventListener('click', () => {
                    // å–æ¶ˆæ‰€æœ‰é€‰ä¸­çš„å…³å¡
                    levelOption.forEach(opt => opt.classList.remove('selected'));
                    
                    // é€‰ä¸­å½“å‰å…³å¡
                    option.classList.add('selected');
                    gameState.currentLevel = parseInt(option.dataset.level);
                    
                    // é‡æ–°å¼€å§‹æ¸¸æˆ
                    startNewLevel();
                    showStatusMessage(`å·²é€‰æ‹©: ${levels[gameState.currentLevel].name}`, "#29B6F6");
                });
            });
            
            difficultyOption.forEach(option => {
                option.addEventListener('click', () => {
                    // å–æ¶ˆæ‰€æœ‰é€‰ä¸­çš„éš¾åº¦
                    difficultyOption.forEach(opt => opt.classList.remove('selected'));
                    
                    // é€‰ä¸­å½“å‰éš¾åº¦
                    option.classList.add('selected');
                    gameState.difficulty = parseInt(option.dataset.difficulty);
                    
                    // é‡æ–°å¼€å§‹æ¸¸æˆ
                    startNewLevel();
                    showStatusMessage(`å·²é€‰æ‹©: ${option.textContent}éš¾åº¦`, "#FFD700");
                });
            });
            
            // å›¾é‰´åŠŸèƒ½
            encyclopediaBtn.addEventListener('click', () => {
                encyclopediaModal.classList.add('active');
            });
            
            closeBtn.addEventListener('click', () => {
                encyclopediaModal.classList.remove('active');
            });
            
            encyclopediaTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    encyclopediaTabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    
                    if (tab.dataset.tab === 'towers') {
                        towersTab.style.display = 'grid';
                        enemiesTab.style.display = 'none';
                        levelsTab.style.display = 'none';
                    } else if (tab.dataset.tab === 'enemies') {
                        towersTab.style.display = 'none';
                        enemiesTab.style.display = 'grid';
                        levelsTab.style.display = 'none';
                    } else {
                        towersTab.style.display = 'none';
                        enemiesTab.style.display = 'none';
                        levelsTab.style.display = 'grid';
                    }
                });
            });
            
            // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
            encyclopediaModal.addEventListener('click', (e) => {
                if (e.target === encyclopediaModal) {
                    encyclopediaModal.classList.remove('active');
                }
            });
            
            canvas.addEventListener('click', (e) => {
                if (gameState.gameOver || gameState.gameWon || gameState.levelComplete) {
                    initGame();
                    return;
                }
                
                if (!gameState.gameRunning) return;
                
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†é˜²å¾¡å¡”
                let clickedTower = false;
                for (const tower of gameState.towers) {
                    const dx = x - tower.x;
                    const dy = y - tower.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 20) {
                        gameState.selectedTower = tower;
                        clickedTower = true;
                        break;
                    }
                }
                
                // å¦‚æœç‚¹å‡»äº†é˜²å¾¡å¡”ï¼Œä¸å†å°è¯•æ”¾ç½®æ–°å¡”
                if (clickedTower) return;
                
                // å¦åˆ™å–æ¶ˆé€‰ä¸­çš„é˜²å¾¡å¡”
                gameState.selectedTower = null;
                
                // å°è¯•æ”¾ç½®é˜²å¾¡å¡”
                if (gameState.selectedTowerType && towerTypes[gameState.selectedTowerType] && gameState.gold >= towerTypes[gameState.selectedTowerType].cost) {
                    // æ£€æŸ¥æ˜¯å¦åœ¨è·¯å¾„ä¸Š
                    let onPath = false;
                    for (let i = 0; i < gameState.path.length - 1; i++) {
                        const p1 = gameState.path[i];
                        const p2 = gameState.path[i + 1];
                        
                        // è®¡ç®—ç‚¹åˆ°çº¿æ®µçš„è·ç¦»
                        const A = x - p1.x;
                        const B = y - p1.y;
                        const C = p2.x - p1.x;
                        const D = p2.y - p1.y;
                        
                        const dot = A * C + B * D;
                        const lenSq = C * C + D * D;
                        let param = -1;
                        
                        if (lenSq !== 0) {
                            param = dot / lenSq;
                        }
                        
                        let xx, yy;
                        
                        if (param < 0) {
                            xx = p1.x;
                            yy = p1.y;
                        } else if (param > 1) {
                            xx = p2.x;
                            yy = p2.y;
                        } else {
                            xx = p1.x + param * C;
                            yy = p1.y + param * D;
                        }
                        
                        const dx = x - xx;
                        const dy = y - yy;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < 35) {
                            onPath = true;
                            break;
                        }
                    }
                    
                    // ä¸åœ¨è·¯å¾„ä¸Šæ‰èƒ½æ”¾ç½®
                    if (!onPath) {
                        createTower(x, y, gameState.selectedTowerType);
                        towerOption.forEach(opt => opt.classList.remove('selected'));
                        gameState.selectedTowerType = null;
                    } else {
                        showStatusMessage("ä¸èƒ½å»ºé€ åœ¨è·¯å¾„ä¸Š!", "#F44336");
                    }
                }
            });
            
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // æ˜¾ç¤ºé˜²å¾¡å¡”å‡çº§ä¿¡æ¯
                for (const tower of gameState.towers) {
                    const dx = x - tower.x;
                    const dy = y - tower.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 20) {
                        upgradeTooltip.style.display = 'block';
                        upgradeTooltip.style.left = (e.clientX + 10) + 'px';
                        upgradeTooltip.style.top = (e.clientY + 10) + 'px';
                        
                        const canUpgrade = tower.level < tower.maxLevel;
                        const upgradeCost = 100;
                        
                        let upgradeInfo = `<div>${towerTypes[tower.type].name} Lv.${tower.level}</div>
                            <div>ä¼¤å®³: ${tower.damage || 'ç‰¹æ®Š'}</div>
                            <div>èŒƒå›´: ${tower.range}</div>
                            <div>æœ€å¤§ç­‰çº§: ${tower.maxLevel}</div>`;
                        
                        // å…µè¥ç‰¹æ®Šä¿¡æ¯
                        if (tower.type === 'barracks') {
                            upgradeInfo += `<div>å£«å…µæ•°é‡: ${tower.soldiers.length}/${tower.maxSoldiers}</div>
                                            <div>å£«å…µä¼¤å®³: ${tower.soldierDamage}</div>
                                            <div>å£«å…µæ”»å‡»èŒƒå›´: ${tower.soldierAttackRange}</div>`;
                        }
                        
                        // ç«ç‚®å¡”ç‰¹æ®Šä¿¡æ¯
                        if (tower.type === 'cannon') {
                            upgradeInfo += `<div>çˆ†ç‚¸èŒƒå›´: ${tower.splashRadius}</div>
                                           <div>æº…å°„ä¼¤å®³: ${tower.splashDamage}</div>`;
                        }
                        
                        // é›·ç”µå¡”ç‰¹æ®Šä¿¡æ¯
                        if (tower.type === 'lightning') {
                            upgradeInfo += `<div>è¿é”æ•°é‡: ${tower.chainCount}</div>
                                           <div>è¿é”èŒƒå›´: ${tower.chainRange}</div>`;
                        }
                        
                        // å¯¼å¼¹å¡”ç‰¹æ®Šä¿¡æ¯
                        if (tower.type === 'missile') {
                            upgradeInfo += `<div>çˆ†ç‚¸èŒƒå›´: ${tower.splashRadius}</div>
                                           <div>æº…å°„ä¼¤å®³: ${tower.splashDamage}</div>`;
                        }
                        
                        // æ¯’å¡”ç‰¹æ®Šä¿¡æ¯
                        if (tower.type === 'poison') {
                            upgradeInfo += `<div>æ¯ç§’ä¼¤å®³: ${tower.damage}</div>
                                           <div>ç™¾åˆ†æ¯”ä¼¤å®³: ${tower.percentDamage * 100}%</div>
                                           <div>å‡é€Ÿæ•ˆæœ: ${(1 - tower.slowEffect) * 100}%</div>`;
                        }
                        
                        // ç¦»å­ç‚®ç‰¹æ®Šä¿¡æ¯
                        if (tower.type === 'ion') {
                            upgradeInfo += `<div>å……èƒ½ä¼¤å®³: ${tower.damage}</div>
                                           <div>çˆ†ç‚¸èŒƒå›´: ${tower.splashRadius}</div>
                                           <div>æº…å°„ä¼¤å®³: ${tower.splashDamage}</div>`;
                        }
                        
                        // å…‰æ£±å¡”ç‰¹æ®Šä¿¡æ¯
                        if (tower.type === 'prism') {
                            upgradeInfo += `<div>æŠ˜å°„æ¬¡æ•°: ${tower.bounceCount}</div>
                                           <div>æŠ˜å°„èŒƒå›´: ${tower.bounceRange}</div>
                                           <div>ä¼¤å®³è¡°å‡: ${tower.bounceDecay * 100}%</div>`;
                        }
                        
                        // å°¤é‡Œå¡”ç‰¹æ®Šä¿¡æ¯
                        if (tower.type === 'yuri') {
                            upgradeInfo += `<div>æ§åˆ¶æ—¶é—´: ${tower.controlDuration/1000}ç§’</div>
                                           <div>å†·å´æ—¶é—´: ${tower.cooldown/1000}ç§’</div>
                                           <div>å½“å‰æ§åˆ¶: ${tower.controlledEnemies.length}</div>`;
                        }
						
						// æ¿€å…‰å¡”ç‰¹æ®Šä¿¡æ¯
                        if (tower.type === 'laser') {
                            upgradeInfo += `<div>æ¯ç§’ä¼¤å®³: ${tower.damage}</div>`;
                        }
                        
                        // æ ¸å¼¹å¡”ç‰¹æ®Šä¿¡æ¯
                        if (tower.type === 'nuke') {
                            upgradeInfo += `<div>å†·å´æ—¶é—´: ${tower.cooldown/1000}ç§’</div>
                                           <div>å…¨å±ä¼¤å®³: ${tower.damage}</div>`;
                        }
                        
                        // è“„èƒ½å¡”ç‰¹æ®Šä¿¡æ¯
                        if (tower.type === 'energizer') {
                            upgradeInfo += `<div>åŸºç¡€ä¼¤å®³: ${tower.damage}</div>
                                           <div>æœ€å¤§ä¼¤å®³: ${tower.maxDamage}</div>
                                           <div>å½“å‰è¿å‡»: ${tower.combo}</div>`;
										   
                        
                        if (canUpgrade) {
                            upgradeInfo += `<div>å‡çº§è´¹ç”¨: $${upgradeCost}</div>
                                           <div>å‡çº§åä¼¤å®³: ${tower.damage ? tower.damage + 10 : 'å¢å¼º'}</div>
                                           <div>å‡çº§åèŒƒå›´: ${tower.range + 15}</div>`;
                            
                            // å…µè¥ç‰¹æ®Šå‡çº§ä¿¡æ¯
                            if (tower.type === 'barracks') {
                                upgradeInfo += `<div>å‡çº§åå£«å…µæ•°é‡: ${tower.maxSoldiers + 1}</div>
                                               <div>å‡çº§åå£«å…µä¼¤å®³: ${tower.soldierDamage + 5}</div>
                                               <div>å‡çº§åå£«å…µæ”»å‡»èŒƒå›´: ${tower.soldierAttackRange + 10}</div>`;
                            }
                            
                            // ç«ç‚®å¡”ç‰¹æ®Šå‡çº§ä¿¡æ¯
                            if (tower.type === 'cannon') {
                                upgradeInfo += `<div>å‡çº§åçˆ†ç‚¸èŒƒå›´: ${tower.splashRadius + 10}</div>
                                               <div>å‡çº§åæº…å°„ä¼¤å®³: ${tower.splashDamage + 5}</div>`;
                            }
                            
                            // é›·ç”µå¡”ç‰¹æ®Šå‡çº§ä¿¡æ¯
                            if (tower.type === 'lightning') {
                                upgradeInfo += `<div>å‡çº§åè¿é”æ•°é‡: ${tower.chainCount + 1}</div>
                                               <div>å‡çº§åè¿é”èŒƒå›´: ${tower.chainRange + 10}</div>`;
                            }
                            
                            // å¯¼å¼¹å¡”ç‰¹æ®Šå‡çº§ä¿¡æ¯
                            if (tower.type === 'missile') {
                                upgradeInfo += `<div>å‡çº§åçˆ†ç‚¸èŒƒå›´: ${tower.splashRadius + 10}</div>
                                               <div>å‡çº§åæº…å°„ä¼¤å®³: ${tower.splashDamage + 5}</div>`;
                            }
                            
                            // æ¯’å¡”ç‰¹æ®Šå‡çº§ä¿¡æ¯
                            if (tower.type === 'poison') {
                                upgradeInfo += `<div>å‡çº§åæ¯ç§’ä¼¤å®³: ${tower.damage + 4}</div>
                                               <div>å‡çº§åç™¾åˆ†æ¯”ä¼¤å®³: ${(tower.percentDamage + 0.005) * 100}%</div>
                                               <div>å‡çº§åå‡é€Ÿæ•ˆæœ: ${(1 - tower.slowEffect * 0.9) * 100}%</div>`;
                            }
                            
                            // ç¦»å­ç‚®ç‰¹æ®Šå‡çº§ä¿¡æ¯
                            if (tower.type === 'ion') {
                                upgradeInfo += `<div>å‡çº§åå……èƒ½ä¼¤å®³: ${tower.damage + 15}</div>
                                               <div>å‡çº§åçˆ†ç‚¸èŒƒå›´: ${tower.splashRadius + 10}</div>
                                               <div>å‡çº§åæº…å°„ä¼¤å®³: ${tower.splashDamage + 10}</div>`;
                            }
                            
                            // å…‰æ£±å¡”ç‰¹æ®Šå‡çº§ä¿¡æ¯
                            if (tower.type === 'prism') {
                                upgradeInfo += `<div>å‡çº§åæŠ˜å°„æ¬¡æ•°: ${tower.bounceCount + 1}</div>
                                               <div>å‡çº§åæŠ˜å°„èŒƒå›´: ${tower.bounceRange + 10}</div>
                                               <div>å‡çº§åä¼¤å®³è¡°å‡: ${(tower.bounceDecay * 0.9) * 100}%</div>`;
                            }
                            
							// æ¿€å…‰å¡”ç‰¹æ®Šå‡çº§ä¿¡æ¯
                            if (tower.type === 'laser') {
                                upgradeInfo += `<div>å‡çº§åæ¯ç§’ä¼¤å®³: ${tower.damage + 8}</div>`;
                            }
                            
                            // è“„èƒ½å¡”ç‰¹æ®Šå‡çº§ä¿¡æ¯
                            if (tower.type === 'energizer') {
                                upgradeInfo += `<div>å‡çº§ååŸºç¡€ä¼¤å®³: ${tower.damage + 5}</div>
                                               <div>å‡çº§åæœ€å¤§ä¼¤å®³: ${tower.maxDamage + 20}</div>
                                               <div>å‡çº§åæœ€å¤§è¿å‡»: ${tower.maxCombo + 2}</div>`;
							}}
                            // å°¤é‡Œå¡”ç‰¹æ®Šå‡çº§ä¿¡æ¯
                            if (tower.type === 'yuri') {
                                upgradeInfo += `<div>å‡çº§åæ§åˆ¶æ—¶é—´: ${(tower.controlDuration + 1000)/1000}ç§’</div>
                                               <div>å‡çº§åå†·å´æ—¶é—´: ${(tower.cooldown - 500)/1000}ç§’</div>`;
                            }
                        } else {
                            upgradeInfo += `<div style="color:#FFD700;">å·²è¾¾æœ€å¤§ç­‰çº§</div>`;
                        }
                        
                        upgradeTooltip.innerHTML = upgradeInfo;
                        return;
                    }
                }
                
                upgradeTooltip.style.display = 'none';
            });
            
            // åˆå§‹åŒ–æ¸¸æˆå’Œå›¾é‰´
            initGame();
            initEncyclopedia();
            requestAnimationFrame(gameLoop);
        });
    </script>
</body>
</html>
